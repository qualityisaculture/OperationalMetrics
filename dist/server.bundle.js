/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/server/BambooRequester.ts":
/*!***************************************!*\
  !*** ./src/server/BambooRequester.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BambooRequester)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass BambooRequester {\n    constructor() {\n        this.cache = {};\n        this.cacheDate = \"\";\n    }\n    getBuildsFromStartIndex(projectBuildKey, startIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const domain = process.env.BAMBOO_DOMAIN;\n            const url = `${domain}/rest/api/latest/result/${projectBuildKey}.json?start-index=${startIndex}`;\n            let results = yield this.fetchRequest(url);\n            let buildNumbers = results.results.result.map((build) => build.buildNumber);\n            let allBuilds = yield Promise.all(buildNumbers.map((buildNumber) => this.getBuild(projectBuildKey, buildNumber)));\n            return allBuilds;\n        });\n    }\n    getBuild(buildResultKey, buildNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const domain = process.env.BAMBOO_DOMAIN;\n            const url = `${domain}/rest/api/latest/result/${buildResultKey}-${buildNumber}.json`;\n            let buildData = yield this.fetchRequest(url);\n            let returnData = {\n                buildNumber: buildData.buildNumber,\n                buildState: buildData.state,\n                buildDate: buildData.buildCompletedDate,\n                buildDurationInMinutes: buildData.buildDurationInSeconds / 60,\n                restartCount: buildData.restartCount || 0,\n                allData: buildData,\n            };\n            return returnData;\n        });\n    }\n    getLastXBuilds(projectBuildKey_1) {\n        return __awaiter(this, arguments, void 0, function* (projectBuildKey, numberOfBuilds = 100) {\n            let cacheDate = new Date().toISOString().split(\"T\")[0];\n            if (this.cache[projectBuildKey] && this.cacheDate === cacheDate) {\n                return this.cache[projectBuildKey];\n            }\n            let builds = [];\n            let startIndex = 0;\n            while (startIndex < numberOfBuilds) {\n                let response = yield this.getBuildsFromStartIndex(projectBuildKey, startIndex);\n                builds = builds.concat(response);\n                startIndex += 25;\n            }\n            this.cache[projectBuildKey] = builds;\n            this.cacheDate = cacheDate;\n            return builds;\n        });\n    }\n    fetchRequest(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const apiToken = process.env.BAMBOO_API_TOKEN;\n            const response = yield fetch(url, {\n                method: \"GET\", // or 'POST', 'PUT', etc. depending on your request\n                headers: {\n                    Authorization: `Bearer ${apiToken}`,\n                    Accept: \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch  data: \" + url + \" \" + response.statusText);\n            }\n            return response.json();\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/BambooRequester.ts?");

/***/ }),

/***/ "./src/server/Jira.ts":
/*!****************************!*\
  !*** ./src/server/Jira.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Jira)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./src/server/Utils.ts\");\n\nclass Jira {\n    constructor(json) {\n        var _a;\n        const domain = process.env.JIRA_DOMAIN;\n        this.created = new Date(json.fields.created);\n        this.fields = {\n            key: json.key,\n            childKeys: [],\n            created: json.fields.created,\n            components: json.fields.components,\n            customfield_10015: json.fields.customfield_10015,\n            customfield_10022: json.fields.customfield_10022,\n            customfield_10023: json.fields.customfield_10023,\n            duedate: json.fields.duedate,\n            fixVersions: json.fields.fixVersions,\n            issuetype: json.fields.issuetype,\n            initiativeKey: json.fields.parent &&\n                json.fields.parent.fields.issuetype.name === \"Sub-feature (AF)\"\n                ? json.fields.parent.key\n                : \"NO_INITIATIVE\",\n            initiativeName: json.fields.parent && json.fields.parent.fields.summary\n                ? json.fields.parent.fields.summary\n                : \"NO_INITIATIVE_SUMMARY\",\n            labels: json.fields.labels,\n            priority: json.fields.priority,\n            resolution: json.fields.resolution,\n            resolutiondate: json.fields.resolutiondate,\n            status: json.fields.status,\n            summary: json.fields.summary,\n            timeoriginalestimateInDays: json.fields.timeoriginalestimate\n                ? json.fields.timeoriginalestimate / 3600 / 7.5\n                : null,\n            timespent: json.fields.timespent\n                ? json.fields.timespent / 3600 / 7.5\n                : null,\n            timeestimateInDays: json.fields.timeestimate\n                ? json.fields.timeestimate / 3600 / 7.5\n                : null,\n            updated: json.fields.updated,\n            url: `${domain}/browse/${json.key}`,\n            account: ((_a = json.fields.customfield_10085) === null || _a === void 0 ? void 0 : _a.value) || \"None\",\n            epicLabels: [], // Initialize epicLabels as an empty array\n        };\n        if (json.fields.parent &&\n            json.fields.parent.fields.issuetype.name === \"Epic\") {\n            this.fields.epicKey = json.fields.parent.key;\n            this.fields.epicName = json.fields.parent.fields.summary;\n        }\n        else if (json.fields.parent &&\n            json.fields.parent.fields.issuetype.name === \"Initiative\") {\n            this.fields.initiativeKey = json.fields.parent.key;\n            this.fields.initiativeName = json.fields.parent.fields.summary;\n        }\n        else if (json.fields.parent) {\n            this.fields.parentKey = json.fields.parent.key;\n            this.fields.parentName = json.fields.parent.fields.summary;\n        }\n        this.changelog = json.changelog || { histories: [] };\n        this.histories =\n            json.changelog && json.changelog.histories\n                ? this.getHistoriesInOrder(json.changelog.histories)\n                : [];\n        this.statusChanges = this.loadStatusChanges();\n    }\n    getKey() {\n        return this.fields.key;\n    }\n    getCreated() {\n        return new Date(this.created);\n    }\n    getComponents() {\n        return this.fields.components.map((component) => {\n            return component.name;\n        });\n    }\n    getEpicKey() {\n        return this.fields.epicKey ? this.fields.epicKey : null;\n    }\n    getEpicName() {\n        return this.fields.epicName ? this.fields.epicName : null;\n    }\n    getFixVersions() {\n        return this.fields.fixVersions.map((version) => {\n            return version.name;\n        });\n    }\n    getInitiativeKey() {\n        return this.fields.initiativeKey;\n    }\n    getInitiativeName() {\n        return this.fields.initiativeName;\n    }\n    getLabels() {\n        return this.fields.labels || [];\n    }\n    getParentKey() {\n        return this.fields.parentKey ? this.fields.parentKey : null;\n    }\n    getParentName() {\n        return this.fields.parentName ? this.fields.parentName : null;\n    }\n    getPriority() {\n        return this.fields.priority.name;\n    }\n    getResolution() {\n        return this.fields.resolution;\n    }\n    getResolved() {\n        return new Date(this.fields.resolutiondate);\n    }\n    getSummary() {\n        return this.fields.summary;\n    }\n    getType() {\n        return this.fields.issuetype.name;\n    }\n    getOriginalEstimate() {\n        return this.fields.timeoriginalestimateInDays || null;\n    }\n    getTimeSpent() {\n        return this.fields.timespent || null;\n    }\n    getTimeRemaining() {\n        return this.fields.timeestimateInDays || null;\n    }\n    getUrl() {\n        return this.fields.url;\n    }\n    getEpicStartDate() {\n        if (!this.fields.customfield_10015 && !this.fields.customfield_10022) {\n            return null;\n        }\n        return new Date(this.fields.customfield_10015 || this.fields.customfield_10022);\n    }\n    getEpicDueDate() {\n        if (!this.fields.duedate && !this.fields.customfield_10023) {\n            return null;\n        }\n        return new Date(this.fields.duedate || this.fields.customfield_10023);\n    }\n    /**\n     *\n     * @param date: If passed, you will receive the children which were linked to that epic on that date/\n     * @returns\n     */\n    getChildrenKeysFromHistories(date) {\n        if (!this.changelog || !this.changelog.histories) {\n            return [];\n        }\n        let children = new Set();\n        let chronologicalEpicChildItems = this.getHistoriesItems(\"Epic Child\");\n        chronologicalEpicChildItems.forEach((item) => {\n            if (item.created && date && item.created > date) {\n                return; //break out of for each\n            }\n            if (item.toString) {\n                children.add(item.toString);\n            }\n            else {\n                children.delete(item.fromString);\n            }\n        });\n        return Array.from(children).map((key) => {\n            return { key };\n        });\n    }\n    getHistoriesItems(field) {\n        let epicChildItems = this.histories\n            .map((history) => {\n            let items = this.filterHistoryItems(history, field);\n            items.forEach((item) => {\n                let date = new Date(history.created);\n                item.created = date;\n            });\n            return items;\n        })\n            .flat();\n        return epicChildItems;\n    }\n    filterHistoryItems(history, field) {\n        return history.items.filter((item) => {\n            return item.field === field;\n        });\n    }\n    getHistoriesInOrder(unsortedHistories) {\n        return unsortedHistories.sort((a, b) => {\n            return new Date(a.created).getTime() - new Date(b.created).getTime();\n        });\n    }\n    loadStatusChanges() {\n        let statusItems = this.getHistoriesItems(\"status\");\n        if (statusItems.length === 0) {\n            return [{ date: this.created, status: this.fields.status.name }];\n        }\n        let statusChanges = statusItems.map((item) => {\n            return { date: new Date(item.created), status: item.toString };\n        });\n        statusChanges.splice(0, 0, {\n            date: this.created,\n            status: statusItems[0].fromString,\n        });\n        return statusChanges;\n    }\n    getStatus(date) {\n        if (!date) {\n            return this.fields.status.name;\n        }\n        if (date < this.created) {\n            return \"NOT_CREATED_YET\";\n        }\n        for (let i = 0; i < this.statusChanges.length; i++) {\n            if (this.statusChanges[i].date > date) {\n                return this.statusChanges[i - 1].status;\n            }\n        }\n        return this.statusChanges[this.statusChanges.length - 1].status;\n    }\n    getStatuses() {\n        let statusSet = new Set();\n        this.statusChanges.forEach((change) => {\n            statusSet.add(change.status);\n        });\n        return Array.from(statusSet).sort();\n    }\n    getStatusDays() {\n        let statuses = this.getStatuses();\n        let statusMap = new Map();\n        statuses.forEach((status) => {\n            statusMap.set(status, 0);\n        });\n        let previousTime = this.statusChanges[0].date;\n        for (let i = 1; i < this.statusChanges.length; i++) {\n            let status = this.statusChanges[i - 1].status;\n            let time = this.statusChanges[i].date;\n            let duration = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getWorkDaysBetween)(previousTime, time);\n            let previousDuration = statusMap.get(status) || 0;\n            statusMap.set(status, previousDuration + duration);\n            previousTime = time;\n        }\n        let finalTime = new Date();\n        let finalDuration = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getWorkDaysBetween)(previousTime, finalTime);\n        let finalStatus = this.getStatus(finalTime);\n        let finalPreviousDuration = statusMap.get(finalStatus) || 0;\n        statusMap.set(finalStatus, finalPreviousDuration + finalDuration);\n        return Array.from(statusMap).map(([status, days]) => {\n            return { status, days };\n        });\n    }\n    isDone(date) {\n        return this.getStatus(date) === \"Done\";\n    }\n    isDoneOrDoing(date) {\n        const status = this.getStatus(date);\n        const inProgressStatuses = [\"In Progress\", \"Verification\", \"Done\"];\n        return inProgressStatuses.includes(status);\n    }\n    isInScope(date) {\n        let descopedStatuses = [\"Cancelled\"];\n        return !descopedStatuses.includes(this.getStatus(date));\n    }\n    existsOn(date) {\n        return date >= this.created;\n    }\n    getAccount() {\n        return this.fields.account;\n    }\n    getEpicLabels() {\n        return this.fields.epicLabels || [];\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/Jira.ts?");

/***/ }),

/***/ "./src/server/JiraRequester.ts":
/*!*************************************!*\
  !*** ./src/server/JiraRequester.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JiraLite: () => (/* binding */ JiraLite),\n/* harmony export */   \"default\": () => (/* binding */ JiraRequester)\n/* harmony export */ });\n/* harmony import */ var _Jira__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Jira */ \"./src/server/Jira.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass JiraLite {\n    constructor(key, summary, type, status, url, children = [], account, hasChildren, priority, baselineEstimate, dueDate = null, epicStartDate = null, epicEndDate = null, links, parent) {\n        this.key = key;\n        this.summary = summary;\n        this.type = type;\n        this.status = status;\n        this.priority = priority;\n        this.account = account;\n        this.children = children;\n        this.childCount = children.length;\n        this.url = url;\n        this.hasChildren = hasChildren;\n        this.baselineEstimate = baselineEstimate;\n        this.dueDate = dueDate;\n        this.epicStartDate = epicStartDate;\n        this.epicEndDate = epicEndDate;\n        this.links = links;\n        this.parent = parent;\n    }\n    static fromLiteJiraIssue(issue) {\n        const children = issue.children.map((child) => typeof child === \"string\"\n            ? new JiraLite(child, \"\", \"\", \"\", \"\", [], \"Unknown\", undefined, undefined, undefined, null, null, null, undefined, null)\n            : JiraLite.fromLiteJiraIssue(child));\n        return new JiraLite(issue.key, issue.summary, issue.type, issue.status, issue.url, children, issue.account, issue.hasChildren, issue.priority, issue.baselineEstimate, issue.dueDate, issue.epicStartDate, issue.epicEndDate, issue.links, issue.parent ? JiraLite.fromLiteJiraIssue(issue.parent) : null);\n    }\n    toLiteJiraIssue() {\n        return {\n            key: this.key,\n            summary: this.summary,\n            type: this.type,\n            status: this.status,\n            priority: this.priority,\n            account: this.account,\n            children: this.children.map((child) => child.toLiteJiraIssue()),\n            childCount: this.childCount,\n            url: this.url,\n            baselineEstimate: this.baselineEstimate,\n            dueDate: this.dueDate,\n            epicStartDate: this.epicStartDate,\n            epicEndDate: this.epicEndDate,\n            hasChildren: this.hasChildren,\n            links: this.links,\n            parent: this.parent ? this.parent.toLiteJiraIssue() : null,\n        };\n    }\n}\nclass JiraRequester {\n    constructor() {\n        this.jiraMap = new Map();\n    }\n    getAdditionalHistory(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let values = [];\n            while (true) {\n                let changelog = yield this.requestChangelogFromServer(key, values.length);\n                values = values.concat(changelog.values);\n                if (changelog.values.length !== 100) {\n                    break;\n                }\n            }\n            return values;\n        });\n    }\n    getFullJiraDataFromKeys(lastUpdatedKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            let uncachedKeys = [];\n            lastUpdatedKeys.forEach((issueRequest) => {\n                var _a;\n                if (this.jiraMap.has(issueRequest.key)) {\n                    let lastUpdated = (_a = this.jiraMap.get(issueRequest.key)) === null || _a === void 0 ? void 0 : _a.fields.updated;\n                    if (issueRequest.updated && issueRequest.updated !== lastUpdated) {\n                        uncachedKeys.push(issueRequest.key);\n                    }\n                }\n                else {\n                    uncachedKeys.push(issueRequest.key);\n                }\n            });\n            let jiraJSON = (yield this.requestIssueFromServer(uncachedKeys).catch((error) => {\n                throw error;\n            }));\n            for (let jira of jiraJSON.issues) {\n                let histories = (_a = jira.changelog) === null || _a === void 0 ? void 0 : _a.histories;\n                if (histories) {\n                    if (histories.length === 100) {\n                        let historyValues = yield this.getAdditionalHistory(jira.key);\n                        jira.changelog.histories = historyValues;\n                    }\n                }\n                this.jiraMap.set(jira.key, yield this.getJiraWithInitiative(jira).catch((error) => {\n                    throw error;\n                }));\n            }\n            return lastUpdatedKeys\n                .map((issueRequest) => {\n                return this.jiraMap.get(issueRequest.key);\n            })\n                .filter((jira) => jira !== undefined);\n        });\n    }\n    getEssentialJiraDataFromKeys(keys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (keys.length === 0) {\n                return [];\n            }\n            const fields = [\"key\", \"summary\", \"resolutiondate\", \"fixVersions\"];\n            return yield this.getBatchedJiraData(keys, fields);\n        });\n    }\n    getBatchedJiraData(keys, fields) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (keys.length === 0) {\n                return [];\n            }\n            let allIssues = [];\n            for (let i = 0; i < keys.length; i += 50) {\n                let batchKeys = keys.slice(i, i + 50);\n                let jql = batchKeys.map((key) => `key=${key}`).join(\" OR \");\n                const fieldsString = fields.join(\",\");\n                const query = `${jql}&fields=${fieldsString}`;\n                let data = yield this.requestDataFromServer(query);\n                allIssues = allIssues.concat(data.issues);\n            }\n            return allIssues;\n        });\n    }\n    getJiraWithInitiative(json) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let jira = new _Jira__WEBPACK_IMPORTED_MODULE_0__[\"default\"](json);\n            let epicKey = jira.getEpicKey();\n            let parentKey = jira.getParentKey();\n            if (parentKey) {\n                let parents = yield this.getFullJiraDataFromKeys([{ key: parentKey }]);\n                let parentjira = parents[0];\n                epicKey = parentjira.getEpicKey();\n            }\n            if (epicKey) {\n                let epics = yield this.getFullJiraDataFromKeys([{ key: epicKey }]);\n                let epicjira = epics[0];\n                let initiativeKey = epicjira.getInitiativeKey();\n                let initiativeName = epicjira.getInitiativeName();\n                let epicLabels = epicjira.getLabels(); // Fetch Epic labels\n                if (initiativeKey !== null && initiativeName !== null) {\n                    jira.fields.initiativeKey = initiativeKey;\n                    jira.fields.initiativeName = initiativeName;\n                }\n                jira.fields.epicLabels = epicLabels; // Add Epic labels to the Jira fields\n            }\n            return jira;\n        });\n    }\n    requestChangelogFromServer(key_1) {\n        return __awaiter(this, arguments, void 0, function* (key, startAt = 0) {\n            const domain = process.env.JIRA_DOMAIN;\n            const url = `${domain}/rest/api/3/issue/${key}/changelog?startAt=${startAt}`;\n            let response = yield this.fetchRequest(url);\n            return response;\n        });\n    }\n    requestIssueFromServer(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (issueKeys.length === 0) {\n                return { issues: [] };\n            }\n            let allIssues = { issues: [] };\n            for (let i = 0; i < issueKeys.length; i += 50) {\n                let keys = issueKeys.slice(i, i + 50);\n                let jql = keys.map((key) => `key=${key}`).join(\" OR \");\n                const query = `${jql}&expand=changelog&fields=issuetype,components,created,customfield_10085,customfield_10022,fixVersions,customfield_10023,priority,resolution,customfield_11753,labels,duedate,updated,status,resolutiondate,summary,timespent,timeoriginalestimate,timeestimate`;\n                let data = yield this.requestDataFromServer(query);\n                allIssues.issues = allIssues.issues.concat(data.issues);\n            }\n            return allIssues;\n        });\n    }\n    getQuery(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastUpdatedKeys = yield this.getJiraKeysInQuery(query);\n            let jiras = yield this.getFullJiraDataFromKeys(lastUpdatedKeys);\n            return jiras;\n        });\n    }\n    getJiraKeysInQuery(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `${query}&fields=key,updated`;\n            let data = yield this.requestDataFromServer(url).catch((error) => {\n                throw error;\n            });\n            return data.issues.map((jira) => {\n                return { key: jira.key, updated: jira.fields.updated };\n            });\n        });\n    }\n    requestDataFromServer(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const domain = process.env.JIRA_DOMAIN;\n            const url = `${domain}/rest/api/3/search/jql?jql=${query}`;\n            console.log(`Fetching data for ${url}`);\n            let response = yield this.fetchRequest(url);\n            let allIssues = response.issues;\n            let nextPageToken = response.nextPageToken;\n            let isLast = response.isLast;\n            // Keep fetching pages while there is a next page token\n            while (!isLast) {\n                let nextResponse = yield this.fetchRequest(`${url}&nextPageToken=${nextPageToken}`);\n                allIssues = allIssues.concat(nextResponse.issues);\n                nextPageToken = nextResponse.nextPageToken;\n                isLast = nextResponse.isLast;\n            }\n            // Update the response object with all collected issues\n            response.issues = allIssues;\n            return response;\n        });\n    }\n    fetchRequest(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const email = process.env.JIRA_EMAIL;\n            const apiToken = process.env.JIRA_API_TOKEN;\n            const response = yield fetch(url, {\n                method: \"GET\", // or 'POST', 'PUT', etc. depending on your request\n                headers: {\n                    Authorization: \"Basic \" + btoa(`${email}:${apiToken}`),\n                    Accept: \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to fetch  data: \" + url + \" \" + response.statusText);\n            }\n            return response.json();\n        });\n    }\n    getReleasesFromProject(projectKey_1) {\n        return __awaiter(this, arguments, void 0, function* (projectKey, count = 10) {\n            const domain = process.env.JIRA_DOMAIN;\n            const url = `${domain}/rest/api/3/project/${projectKey}/versions`;\n            let response = yield this.fetchRequest(url);\n            let releasedReleases = response.filter((release) => release.released);\n            return releasedReleases.slice(-count);\n        });\n    }\n    getTimeTrackingData(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (issueKeys.length === 0) {\n                return {};\n            }\n            try {\n                console.log(`Fetching time tracking data for ${issueKeys.length} issues...`);\n                // Batch issue keys into groups of 50 to avoid Jira API limits\n                // Similar to how requestIssueFromServer handles batching\n                const batchSize = 50;\n                const allLastUpdatedKeys = [];\n                for (let i = 0; i < issueKeys.length; i += batchSize) {\n                    const batchKeys = issueKeys.slice(i, i + batchSize);\n                    console.log(`Fetching updated timestamps for batch ${Math.floor(i / batchSize) + 1} (${batchKeys.length} keys)...`);\n                    // Get updated timestamps for this batch\n                    const batchQuery = batchKeys.map((key) => `key=${key}`).join(\" OR \");\n                    const batchLastUpdatedKeys = yield this.getJiraKeysInQuery(batchQuery);\n                    allLastUpdatedKeys.push(...batchLastUpdatedKeys);\n                    console.log(`Batch ${Math.floor(i / batchSize) + 1} complete: got ${batchLastUpdatedKeys.length} keys`);\n                }\n                console.log(`Total keys retrieved: ${allLastUpdatedKeys.length} out of ${issueKeys.length} requested`);\n                // Use getFullJiraDataFromKeys which handles caching and updates properly\n                const jiras = yield this.getFullJiraDataFromKeys(allLastUpdatedKeys);\n                const timeTrackingData = {};\n                // Process all Jira objects (from cache or freshly fetched)\n                for (const jira of jiras) {\n                    if (!jira)\n                        continue;\n                    const issueKey = jira.fields.key;\n                    const histories = ((_a = jira.changelog) === null || _a === void 0 ? void 0 : _a.histories) || [];\n                    console.log(`Processing changelog for ${issueKey} with ${histories.length} history entries`);\n                    const timeEntriesRaw = this.extractLatestWorklogTimespent(histories);\n                    // Convert raw seconds to minutes and days\n                    timeTrackingData[issueKey] = timeEntriesRaw.map((entry) => {\n                        const seconds = entry.timeSpent;\n                        const minutes = seconds / 60;\n                        const days = minutes / 60 / 7.5; // Assuming 7.5 hours per day\n                        return {\n                            date: entry.date,\n                            timeSpent: seconds, // Keep raw seconds for backward compatibility\n                            timeSpentMinutes: minutes,\n                            timeSpentDays: days,\n                        };\n                    });\n                    if (timeTrackingData[issueKey].length > 0) {\n                        console.log(`Total time entries for ${issueKey}: ${timeTrackingData[issueKey].length} dates`);\n                    }\n                }\n                console.log(`Successfully processed time tracking data for ${Object.keys(timeTrackingData).length} issues`);\n                console.log(`getTimeTrackingData response - keys with data:`, Object.keys(timeTrackingData));\n                console.log(`getTimeTrackingData response - requested ${issueKeys.length} keys, got ${Object.keys(timeTrackingData).length} keys`);\n                const missingKeys = issueKeys.filter((key) => !(key in timeTrackingData));\n                if (missingKeys.length > 0) {\n                    console.log(`getTimeTrackingData - missing keys (no changelog or not found):`, missingKeys);\n                }\n                return timeTrackingData;\n            }\n            catch (error) {\n                console.error(\"Error fetching time tracking data:\", error);\n                throw error;\n            }\n        });\n    }\n    extractLatestWorklogTimespent(histories) {\n        if (!histories || histories.length === 0) {\n            return [];\n        }\n        // Process histories in chronological order (oldest first)\n        const sortedHistories = [...histories].sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime());\n        // Map to track the final timespent value for each date\n        // Key: date (YYYY-MM-DD), Value: final timespent in seconds for that date\n        const timespentByDate = new Map();\n        // Process each history entry chronologically\n        for (const history of sortedHistories) {\n            const historyDate = history.created.split(\"T\")[0]; // YYYY-MM-DD format\n            // Find timespent changes in this history entry\n            const timespentItem = history.items.find((item) => item.field === \"timespent\");\n            if (timespentItem && timespentItem.toString) {\n                // Get the final timespent value for this date (cumulative)\n                const finalTimespentSeconds = parseInt(timespentItem.toString || \"0\");\n                timespentByDate.set(historyDate, finalTimespentSeconds);\n            }\n        }\n        // Convert to incremental time spent per date\n        // For each date, calculate the difference from the previous date's final value\n        const result = [];\n        let previousTimespentSeconds = 0;\n        const sortedDates = Array.from(timespentByDate.keys()).sort();\n        for (const date of sortedDates) {\n            const currentTimespentSeconds = timespentByDate.get(date) || 0;\n            const incrementalSeconds = currentTimespentSeconds - previousTimespentSeconds;\n            // Include both positive and negative changes (worklogs can be added or removed)\n            if (incrementalSeconds !== 0) {\n                // Return raw seconds as integer (can be negative)\n                result.push({\n                    date,\n                    timeSpent: incrementalSeconds,\n                });\n            }\n            previousTimespentSeconds = currentTimespentSeconds;\n        }\n        console.log(`Extracted time tracking data for ${result.length} dates from ${sortedHistories.length} history entries`);\n        return result;\n    }\n    getProjects() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const domain = process.env.JIRA_DOMAIN;\n            const url = `${domain}/rest/api/3/project/search`;\n            console.log(`Fetching projects from ${url}`);\n            let response = yield this.fetchRequest(url);\n            // Handle pagination if there are more than 50 projects\n            if (response.total > 50) {\n                let startAt = 50;\n                while (startAt < response.total) {\n                    console.log(`Fetching next 50 projects of ${response.total}, startAt: ${startAt}`);\n                    let nextResponse = yield this.fetchRequest(`${url}?startAt=${startAt}`);\n                    response.values = response.values.concat(nextResponse.values);\n                    startAt += 50;\n                }\n            }\n            // Return simplified project data with just the fields we need\n            return response.values.map((project) => ({\n                id: project.id,\n                key: project.key,\n                name: project.name,\n                url: `${domain}/browse/${project.key}`,\n            }));\n        });\n    }\n    getLiteQuery(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const domain = process.env.JIRA_DOMAIN;\n                const url = `${domain}/rest/api/3/search/jql?jql=${query}&fields=key,summary,issuetype,status,priority,customfield_10085,customfield_11753,duedate,customfield_10022,customfield_10023,timeoriginalestimate,timespent,timeestimate`;\n                console.log(`Fetching lite data for ${url}`);\n                let response = yield this.fetchRequest(url);\n                let allIssues = response.issues;\n                let nextPageToken = response.nextPageToken;\n                let isLast = response.isLast;\n                // Keep fetching pages while there is a next page token\n                while (!isLast) {\n                    let nextResponse = yield this.fetchRequest(`${url}&nextPageToken=${nextPageToken}`);\n                    allIssues = allIssues.concat(nextResponse.issues);\n                    nextPageToken = nextResponse.nextPageToken;\n                    isLast = nextResponse.isLast;\n                }\n                // Get the top-level issues (those that are not children of other issues)\n                const topLevelIssues = allIssues.filter((issue) => {\n                    // Filter out subtasks and issues that have parents\n                    return (issue.fields.issuetype.name !== \"Sub-task\" && !issue.fields.parent);\n                });\n                // Return issues without children data for faster loading\n                return topLevelIssues.map((issue) => {\n                    var _a, _b, _c;\n                    return ({\n                        key: issue.key,\n                        summary: issue.fields.summary || \"\",\n                        type: issue.fields.issuetype.name || \"\",\n                        status: ((_a = issue.fields.status) === null || _a === void 0 ? void 0 : _a.name) || \"\",\n                        priority: ((_b = issue.fields.priority) === null || _b === void 0 ? void 0 : _b.name) || \"None\",\n                        account: ((_c = issue.fields.customfield_10085) === null || _c === void 0 ? void 0 : _c.value) || \"None\",\n                        children: [], // No children data\n                        childCount: 0, // No child count\n                        url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                        baselineEstimate: issue.fields.customfield_11753\n                            ? issue.fields.customfield_11753\n                            : null,\n                        originalEstimate: issue.fields.timeoriginalestimate\n                            ? issue.fields.timeoriginalestimate / 3600 / 7.5\n                            : null,\n                        timeSpent: issue.fields.timespent\n                            ? issue.fields.timespent / 3600 / 7.5\n                            : null,\n                        timeRemaining: issue.fields.timeestimate\n                            ? issue.fields.timeestimate / 3600 / 7.5\n                            : null,\n                        dueDate: issue.fields.duedate || null, // Always include dueDate field\n                        epicStartDate: issue.fields.customfield_10022 || null, // Epic Start Date (fallback)\n                        epicEndDate: issue.fields.customfield_10023 || null, // Epic End Date (fallback)\n                    });\n                });\n            }\n            catch (error) {\n                console.error(\"Error in getLiteQuery:\", error);\n                throw error;\n            }\n        });\n    }\n    getAllChildrenForIssues(parentKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (parentKeys.length === 0) {\n                    return [];\n                }\n                const allChildren = [];\n                const batchSize = 50; // Process 50 parents at a time\n                for (let i = 0; i < parentKeys.length; i += batchSize) {\n                    const parentBatch = parentKeys.slice(i, i + batchSize);\n                    const parentConditions = parentBatch\n                        .map((key) => `parent = \"${key}\"`)\n                        .join(\" OR \");\n                    const jql = `(${parentConditions}) ORDER BY created ASC`;\n                    const fields = \"key,summary,issuetype,parent,status,priority,timeoriginalestimate,timespent,timeestimate,customfield_10085,customfield_11753,duedate,customfield_10022,customfield_10023,issuelinks\";\n                    const queryWithFields = `${jql}&fields=${fields}`;\n                    console.log(`Fetching children for batch of ${parentBatch.length} parent issues (total ${parentKeys.length})`);\n                    const response = yield this.requestDataFromServer(queryWithFields);\n                    const children = response.issues.map((issue) => {\n                        var _a, _b, _c, _d;\n                        // Process issue links\n                        const links = [];\n                        if (issue.fields.issuelinks) {\n                            for (const link of issue.fields.issuelinks) {\n                                // Handle both inward and outward links\n                                if (link.inwardIssue) {\n                                    links.push({\n                                        type: link.type.name,\n                                        linkedIssueKey: link.inwardIssue.key,\n                                        direction: \"inward\",\n                                    });\n                                }\n                                if (link.outwardIssue) {\n                                    links.push({\n                                        type: link.type.name,\n                                        linkedIssueKey: link.outwardIssue.key,\n                                        direction: \"outward\",\n                                    });\n                                }\n                            }\n                        }\n                        return {\n                            key: issue.key,\n                            summary: issue.fields.summary || \"\",\n                            type: issue.fields.issuetype.name || \"\",\n                            status: ((_a = issue.fields.status) === null || _a === void 0 ? void 0 : _a.name) || \"\",\n                            priority: ((_b = issue.fields.priority) === null || _b === void 0 ? void 0 : _b.name) || \"None\",\n                            account: ((_c = issue.fields.customfield_10085) === null || _c === void 0 ? void 0 : _c.value) || \"None\",\n                            parentKey: ((_d = issue.fields.parent) === null || _d === void 0 ? void 0 : _d.key) || \"\",\n                            url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                            baselineEstimate: issue.fields.customfield_11753\n                                ? issue.fields.customfield_11753\n                                : null,\n                            originalEstimate: issue.fields.timeoriginalestimate\n                                ? issue.fields.timeoriginalestimate / 3600 / 7.5\n                                : null,\n                            timeSpent: issue.fields.timespent\n                                ? issue.fields.timespent / 3600 / 7.5\n                                : null,\n                            timeRemaining: issue.fields.timeestimate\n                                ? issue.fields.timeestimate / 3600 / 7.5\n                                : null,\n                            dueDate: issue.fields.duedate || null, // Always include dueDate field\n                            epicStartDate: issue.fields.customfield_10022 || null, // Epic Start Date (fallback)\n                            epicEndDate: issue.fields.customfield_10023 || null, // Epic End Date (fallback)\n                            links: links, // Add links to the issue data\n                        };\n                    });\n                    allChildren.push(...children);\n                }\n                return allChildren;\n            }\n            catch (error) {\n                console.error(`Error fetching children for issues:`, error);\n                throw error;\n            }\n        });\n    }\n    getChildrenForIssue(parentKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const domain = process.env.JIRA_DOMAIN;\n                // Query for issues where the parent field matches the parentKey\n                const jql = `parent = \"${parentKey}\" ORDER BY created ASC`;\n                const fields = \"key,summary,issuetype,status,priority,timeoriginalestimate,timespent,timeestimate,customfield_10085,customfield_11753,duedate,customfield_10022,customfield_10023\";\n                const url = `${domain}/rest/api/3/search/jql?jql=${jql}&fields=${fields}`;\n                let response = yield this.fetchRequest(url);\n                let allIssues = response.issues;\n                let nextPageToken = response.nextPageToken;\n                let isLast = response.isLast;\n                // Keep fetching pages while there is a next page token\n                while (!isLast) {\n                    let nextResponse = yield this.fetchRequest(`${url}&nextPageToken=${nextPageToken}`);\n                    allIssues = allIssues.concat(nextResponse.issues);\n                    nextPageToken = nextResponse.nextPageToken;\n                    isLast = nextResponse.isLast;\n                }\n                // Transform children to LiteJiraIssue format (children don't have their own children in this context)\n                return allIssues.map((issue) => {\n                    var _a, _b, _c;\n                    return ({\n                        key: issue.key,\n                        summary: issue.fields.summary || \"\",\n                        type: issue.fields.issuetype.name || \"\",\n                        status: ((_a = issue.fields.status) === null || _a === void 0 ? void 0 : _a.name) || \"\",\n                        priority: ((_b = issue.fields.priority) === null || _b === void 0 ? void 0 : _b.name) || \"None\",\n                        account: ((_c = issue.fields.customfield_10085) === null || _c === void 0 ? void 0 : _c.value) || \"None\",\n                        children: [], // Children don't have nested children in this implementation\n                        childCount: 0,\n                        url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                        baselineEstimate: issue.fields.customfield_11753\n                            ? issue.fields.customfield_11753\n                            : null,\n                        originalEstimate: issue.fields.timeoriginalestimate\n                            ? issue.fields.timeoriginalestimate / 3600 / 7.5\n                            : null,\n                        timeSpent: issue.fields.timespent\n                            ? issue.fields.timespent / 3600 / 7.5\n                            : null,\n                        timeRemaining: issue.fields.timeestimate\n                            ? issue.fields.timeestimate / 3600 / 7.5\n                            : null,\n                        dueDate: issue.fields.duedate || null, // Always include dueDate field\n                        epicStartDate: issue.fields.customfield_10022 || null, // Epic Start Date (fallback)\n                        epicEndDate: issue.fields.customfield_10023 || null, // Epic End Date (fallback)\n                    });\n                });\n            }\n            catch (error) {\n                console.error(`Error fetching children for issue ${parentKey}:`, error);\n                return [];\n            }\n        });\n    }\n    // New method to fetch issue links for a given issue\n    getIssueLinks(issueKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const domain = process.env.JIRA_DOMAIN;\n                const url = `${domain}/rest/api/3/issue/${issueKey}?fields=issuelinks`;\n                const response = yield this.fetchRequest(url);\n                const issueLinks = response.fields.issuelinks || [];\n                const links = [];\n                for (const link of issueLinks) {\n                    // Handle both inward and outward links\n                    if (link.inwardIssue) {\n                        links.push({\n                            type: link.type.name,\n                            inwardIssue: link.inwardIssue.key,\n                            outwardIssue: issueKey,\n                            direction: \"inward\",\n                        });\n                    }\n                    if (link.outwardIssue) {\n                        links.push({\n                            type: link.type.name,\n                            inwardIssue: issueKey,\n                            outwardIssue: link.outwardIssue.key,\n                            direction: \"outward\",\n                        });\n                    }\n                }\n                return links;\n            }\n            catch (error) {\n                console.error(`Error fetching links for issue ${issueKey}:`, error);\n                return [];\n            }\n        });\n    }\n    // New method to get parent information for an issue\n    getIssueParent(issueKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n                const domain = process.env.JIRA_DOMAIN;\n                const url = `${domain}/rest/api/3/issue/${issueKey}?fields=parent`;\n                const response = yield this.fetchRequest(url);\n                const parent = ((_a = response.fields) === null || _a === void 0 ? void 0 : _a.parent) || null;\n                if (parent) {\n                    return {\n                        parentKey: parent.key,\n                        parentSummary: parent.fields.summary,\n                    };\n                }\n                return {\n                    parentKey: null,\n                    parentSummary: null,\n                };\n            }\n            catch (error) {\n                console.error(`Error fetching parent for issue ${issueKey}:`, error);\n                return {\n                    parentKey: null,\n                    parentSummary: null,\n                };\n            }\n        });\n    }\n    // Method to get individual issues by their keys\n    getIssuesByKeys(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (issueKeys.length === 0) {\n                    return [];\n                }\n                const allIssues = [];\n                const batchSize = 50; // Process 50 issues at a time\n                for (let i = 0; i < issueKeys.length; i += batchSize) {\n                    const batchKeys = issueKeys.slice(i, i + batchSize);\n                    const keyConditions = batchKeys\n                        .map((key) => `key = \"${key}\"`)\n                        .join(\" OR \");\n                    const jql = `(${keyConditions}) ORDER BY created ASC`;\n                    const fields = \"key,summary,issuetype,parent,status,priority,timeoriginalestimate,timespent,timeestimate,customfield_10085,customfield_11753,duedate,customfield_10022,customfield_10023,issuelinks\";\n                    const queryWithFields = `${jql}&fields=${fields}`;\n                    console.log(`Fetching ${batchKeys.length} issues by keys (batch ${Math.floor(i / batchSize) + 1})`);\n                    const response = yield this.requestDataFromServer(queryWithFields);\n                    const issues = response.issues.map((issue) => {\n                        var _a, _b, _c;\n                        // Process issue links\n                        const links = [];\n                        if (issue.fields.issuelinks) {\n                            for (const link of issue.fields.issuelinks) {\n                                // Handle both inward and outward links\n                                if (link.inwardIssue) {\n                                    links.push({\n                                        type: link.type.name,\n                                        linkedIssueKey: link.inwardIssue.key,\n                                        direction: \"inward\",\n                                    });\n                                }\n                                if (link.outwardIssue) {\n                                    links.push({\n                                        type: link.type.name,\n                                        linkedIssueKey: link.outwardIssue.key,\n                                        direction: \"outward\",\n                                    });\n                                }\n                            }\n                        }\n                        return {\n                            key: issue.key,\n                            summary: issue.fields.summary || \"\",\n                            type: issue.fields.issuetype.name || \"\",\n                            status: ((_a = issue.fields.status) === null || _a === void 0 ? void 0 : _a.name) || \"\",\n                            priority: ((_b = issue.fields.priority) === null || _b === void 0 ? void 0 : _b.name) || \"None\",\n                            account: ((_c = issue.fields.customfield_10085) === null || _c === void 0 ? void 0 : _c.value) || \"None\",\n                            children: [], // We don't fetch children here\n                            childCount: 0,\n                            url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                            baselineEstimate: issue.fields.customfield_11753\n                                ? issue.fields.customfield_11753\n                                : null,\n                            originalEstimate: issue.fields.timeoriginalestimate\n                                ? issue.fields.timeoriginalestimate / 3600 / 7.5\n                                : null,\n                            timeSpent: issue.fields.timespent\n                                ? issue.fields.timespent / 3600 / 7.5\n                                : null,\n                            timeRemaining: issue.fields.timeestimate\n                                ? issue.fields.timeestimate / 3600 / 7.5\n                                : null,\n                            dueDate: issue.fields.duedate || null,\n                            epicStartDate: issue.fields.customfield_10022 || null,\n                            epicEndDate: issue.fields.customfield_10023 || null,\n                            links: links,\n                            parent: null, // Will be set later when building the tree\n                        };\n                    });\n                    allIssues.push(...issues);\n                }\n                return allIssues;\n            }\n            catch (error) {\n                console.error(`Error fetching issues by keys:`, error);\n                throw error;\n            }\n        });\n    }\n    // New method to get all parents for a list of issues (breadth-first, batched)\n    getAllParentsForIssues(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (issueKeys.length === 0) {\n                    return new Map();\n                }\n                const allParents = new Map();\n                const issuesToProcess = new Set(issueKeys);\n                const processedIssues = new Set();\n                let levelNumber = 0;\n                console.log(`Starting recursive parent fetching for ${issueKeys.length} issues`);\n                while (issuesToProcess.size > 0) {\n                    levelNumber++;\n                    const currentLevelKeys = Array.from(issuesToProcess);\n                    issuesToProcess.clear();\n                    console.log(`Level ${levelNumber}: Processing ${currentLevelKeys.length} issues for parents`);\n                    // Batch fetch parent information for all issues at this level\n                    const parentData = yield this.getBatchedParentData(currentLevelKeys);\n                    for (const issueData of parentData) {\n                        if (issueData.parentKey &&\n                            !processedIssues.has(issueData.parentKey)) {\n                            // Add the parent to the map\n                            allParents.set(issueData.parentKey, {\n                                key: issueData.parentKey,\n                                summary: issueData.parentSummary || `Issue ${issueData.parentKey}`,\n                                type: \"Parent\", // We don't know the type without fetching\n                                status: \"Unknown\",\n                                account: \"Unknown\",\n                                children: [],\n                                childCount: 0,\n                                url: `${process.env.JIRA_DOMAIN}/browse/${issueData.parentKey}`,\n                                originalEstimate: null,\n                                timeSpent: null,\n                                timeRemaining: null,\n                                dueDate: null,\n                                epicStartDate: null,\n                                epicEndDate: null,\n                                parent: null,\n                            });\n                            // Add to next level for further parent fetching\n                            issuesToProcess.add(issueData.parentKey);\n                        }\n                        processedIssues.add(issueData.issueKey);\n                    }\n                    // Safety check to prevent infinite loops\n                    if (levelNumber > 10) {\n                        console.warn(`Reached maximum parent level depth (10), stopping to prgetParentKeysForIssuesevent infinite loop`);\n                        break;\n                    }\n                }\n                console.log(`Completed parent fetching: found ${allParents.size} total parents across ${levelNumber} levels`);\n                return allParents;\n            }\n            catch (error) {\n                console.error(`Error fetching parents for issues:`, error);\n                throw error;\n            }\n        });\n    }\n    // Helper method to batch fetch parent data\n    getBatchedParentData(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const results = [];\n            // Process in batches of 50\n            for (let i = 0; i < issueKeys.length; i += 50) {\n                const batchKeys = issueKeys.slice(i, i + 50);\n                // Create JQL query for this batch\n                const jql = batchKeys.map((key) => `key = \"${key}\"`).join(\" OR \");\n                const fields = \"key,parent\";\n                const query = `${jql}&fields=${fields}`;\n                try {\n                    const response = yield this.requestDataFromServer(query);\n                    for (const issue of response.issues) {\n                        const parent = (_a = issue.fields) === null || _a === void 0 ? void 0 : _a.parent;\n                        results.push({\n                            issueKey: issue.key,\n                            parentKey: (parent === null || parent === void 0 ? void 0 : parent.key) || null,\n                            parentSummary: ((_b = parent === null || parent === void 0 ? void 0 : parent.fields) === null || _b === void 0 ? void 0 : _b.summary) || null,\n                        });\n                    }\n                }\n                catch (error) {\n                    console.error(`Error fetching parent data for batch:`, error);\n                    // Add null results for this batch\n                    for (const key of batchKeys) {\n                        results.push({\n                            issueKey: key,\n                            parentKey: null,\n                            parentSummary: null,\n                        });\n                    }\n                }\n            }\n            return results;\n        });\n    }\n    // Method to get worklogs for issues by Account and month\n    getWorklogsForAccountMonth(account, year, month) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log(`Fetching worklogs for account ${account} for ${year}-${month.toString().padStart(2, \"0\")}`);\n                // Create date range for the month\n                const startDate = `${year}-${month.toString().padStart(2, \"0\")}-01`;\n                const endDate = new Date(year, month, 0).toISOString().split(\"T\")[0]; // Last day of the month\n                // JQL query to find issues with worklogs in the specified month and account\n                const jql = `\"Account\" = \"${account}\" AND worklogDate >= \"${startDate}\" AND worklogDate <= \"${endDate}\"`;\n                console.log(`JQL Query: ${jql}`);\n                // Get issues with worklogs in the specified month\n                const issues = yield this.getLiteQuery(jql);\n                console.log(`Found ${issues.length} issues with worklogs for account ${account} in ${year}-${month.toString().padStart(2, \"0\")}`);\n                // Log each issue found\n                for (const issue of issues) {\n                    console.log(`Issue found: ${issue.key} (${issue.summary}) - Account: ${issue.account}`);\n                }\n                const allWorklogs = [];\n                // For each issue, get its worklogs\n                for (const issue of issues) {\n                    try {\n                        console.log(`Fetching worklogs for issue ${issue.key}`);\n                        const worklogs = yield this.getIssueWorklogs(issue.key);\n                        console.log(`Found ${worklogs.length} total worklogs for issue ${issue.key}`);\n                        // Filter worklogs to only include those from the specified month\n                        const monthWorklogs = worklogs.filter((worklog) => {\n                            const worklogDate = new Date(worklog.started);\n                            const isInMonth = worklogDate.getFullYear() === year &&\n                                worklogDate.getMonth() === month - 1; // month is 0-indexed in Date\n                            console.log(`Worklog ${worklog.id} started ${worklog.started}, in target month: ${isInMonth}`);\n                            return isInMonth;\n                        });\n                        console.log(`Filtered to ${monthWorklogs.length} worklogs in target month for issue ${issue.key}`);\n                        // Add to results with issue key\n                        for (const worklog of monthWorklogs) {\n                            console.log(`Adding worklog: ${worklog.id} by ${worklog.author.displayName} for ${worklog.timeSpent}`);\n                            allWorklogs.push({\n                                issueKey: issue.key,\n                                worklogId: worklog.id,\n                                author: worklog.author.displayName,\n                                timeSpent: worklog.timeSpent, // This is a string like \"2h 30m\"\n                                timeSpentSeconds: worklog.timeSpentSeconds,\n                                started: worklog.started,\n                                comment: worklog.comment,\n                            });\n                        }\n                    }\n                    catch (error) {\n                        console.error(`Error fetching worklogs for issue ${issue.key}:`, error);\n                    }\n                }\n                console.log(`Retrieved ${allWorklogs.length} worklogs for account ${account} for ${year}-${month.toString().padStart(2, \"0\")}`);\n                return allWorklogs;\n            }\n            catch (error) {\n                console.error(`Error fetching worklogs for account ${account}:`, error);\n                throw error;\n            }\n        });\n    }\n    // Method to get worklogs for a specific issue\n    getIssueWorklogs(issueKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const domain = process.env.JIRA_DOMAIN;\n                const url = `${domain}/rest/api/3/issue/${issueKey}/worklog`;\n                const response = yield this.fetchRequest(url);\n                return response.worklogs || [];\n            }\n            catch (error) {\n                console.error(`Error fetching worklogs for issue ${issueKey}:`, error);\n                return [];\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/JiraRequester.ts?");

/***/ }),

/***/ "./src/server/Utils.ts":
/*!*****************************!*\
  !*** ./src/server/Utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIssueInfoFromJira: () => (/* binding */ getIssueInfoFromJira),\n/* harmony export */   getIssuesBySprint: () => (/* binding */ getIssuesBySprint),\n/* harmony export */   getSprintIssueListsBySprint: () => (/* binding */ getSprintIssueListsBySprint),\n/* harmony export */   getWorkDaysBetween: () => (/* binding */ getWorkDaysBetween),\n/* harmony export */   inWorkDay: () => (/* binding */ inWorkDay)\n/* harmony export */ });\nfunction inWorkDay(date) {\n    if (date.getDay() == 6 || date.getDay() == 0) {\n        return false;\n    }\n    if (date.getUTCHours() < 9) {\n        return false;\n    }\n    if (date.getUTCHours() >= 17) {\n        return false;\n    }\n    return true;\n}\n//Not accurate to the minute, but good enough for this use case\nfunction getWorkDaysBetween(date1, date2) {\n    if (date2.getTime() - date1.getTime() < 60 * 60 * 1000) {\n        return 0;\n    }\n    let workHours = 0;\n    let currentDate = new Date(date1);\n    while (currentDate < date2) {\n        if (inWorkDay(currentDate)) {\n            workHours++;\n        }\n        currentDate.setUTCHours(currentDate.getUTCHours() + 1);\n    }\n    return workHours / 8;\n}\nfunction getSprintIssueListsBySprint(jiras, startDate) {\n    let issuesBySprint = getIssuesBySprint(jiras, startDate);\n    let sprintIssueLists = issuesBySprint.map((sprint) => {\n        return {\n            sprintStartingDate: sprint.sprintStartingDate,\n            issueList: sprint.issues.map((jira) => getIssueInfoFromJira(jira)),\n        };\n    });\n    return sprintIssueLists;\n}\nfunction getIssuesBySprint(jiras, startDate) {\n    let sprints = [];\n    let currentSprintStartDate = new Date(startDate);\n    currentSprintStartDate.setDate(currentSprintStartDate.getDate() + 14);\n    while (jiras.length > 0) {\n        let twoWeeksAgo = new Date(currentSprintStartDate);\n        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);\n        let jirasInSprint = jiras.filter((jira) => jira.getResolved() > twoWeeksAgo);\n        sprints.push({\n            sprintStartingDate: twoWeeksAgo,\n            issues: jirasInSprint,\n        });\n        jiras = jiras.filter((jira) => jira.getResolved() <= twoWeeksAgo);\n        currentSprintStartDate = twoWeeksAgo;\n    }\n    return sprints;\n}\nfunction getIssueInfoFromJira(jira) {\n    let initiativeKey = jira.getInitiativeKey();\n    let initiativeName = jira.getInitiativeName();\n    if (initiativeKey == \"NO_INITIATIVE\") {\n        if (jira.getType() === \"Bug\") {\n            initiativeKey = \"Bug\";\n            initiativeName = \"Bug\";\n        }\n        else if (jira.getEpicKey()) {\n            initiativeKey = \"EPIC\";\n            initiativeName = \"NOINITIATIVE\";\n        }\n    }\n    let labels = jira.getLabels();\n    if (labels.includes(\"corrected\")) {\n        initiativeKey = \"CORRECTED\";\n        initiativeName = \"CORRECTED\";\n    }\n    if (jira.getEpicKey()) {\n        const epicLabels = jira.getEpicLabels();\n        if (epicLabels.includes(\"corrected\")) {\n            initiativeKey = \"EPIC_CORRECTED\";\n            initiativeName = \"EPIC_CORRECTED\";\n        }\n    }\n    return {\n        key: jira.getKey(),\n        summary: jira.getSummary(),\n        status: jira.getStatus(),\n        type: jira.getType(),\n        created: jira.getCreated().toISOString(),\n        resolved: jira.getResolved().toISOString(),\n        resolution: jira.getResolution(),\n        epicKey: jira.getEpicKey(),\n        epicName: jira.getEpicName(),\n        initiativeKey: initiativeKey,\n        initiativeName: initiativeName,\n        labels: jira.getLabels(),\n        priority: jira.getPriority(),\n        components: jira.getComponents(),\n        fixVersions: jira.getFixVersions(),\n        url: jira.getUrl(),\n        timeoriginalestimate: jira.getOriginalEstimate(),\n        timespent: jira.getTimeSpent(),\n        account: jira.getAccount(),\n    };\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/Utils.ts?");

/***/ }),

/***/ "./src/server/graphManagers/BambooGraphManager.ts":
/*!********************************************************!*\
  !*** ./src/server/graphManagers/BambooGraphManager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BambooGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass BambooGraphManager {\n    constructor(bambooRequester) {\n        this.bambooRequester = bambooRequester;\n    }\n    weekOfYear(date) {\n        const startOfYear = new Date(date.getFullYear(), 0, 1);\n        startOfYear.setDate(startOfYear.getDate() + (startOfYear.getDay() % 7));\n        //@ts-ignore\n        return Math.round((date - startOfYear) / 604800000);\n    }\n    getBuildDataByWeek(projectBuildKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let builds = yield this.bambooRequester.getLastXBuilds(projectBuildKey, 200);\n            let buildsByMonthAndYear = builds.reduce((acc, build) => {\n                let date = new Date(build.buildDate);\n                // let month = ('0' + (date.getMonth() + 1)).slice(-2);\n                let year = date.getFullYear();\n                let week = this.weekOfYear(date);\n                let key = `${year}-${week}`;\n                if (acc[key]) {\n                    acc[key].push(build);\n                }\n                else {\n                    acc[key] = [build];\n                }\n                return acc;\n            }, {});\n            let arrayOfBuildsByMonth = Object.keys(buildsByMonthAndYear).map((key) => {\n                return {\n                    month: key,\n                    builds: buildsByMonthAndYear[key],\n                    totalBuilds: 0,\n                    passBuilds: 0,\n                    restartedBuilds: 0,\n                    passFirstTimeBuilds: 0,\n                    successRate: 0,\n                    failureRate: 0,\n                    restartRate: 0,\n                    passFirstTimeRate: 0,\n                    averageBuildTime: 0,\n                };\n            });\n            arrayOfBuildsByMonth.forEach((buildsByMonth) => {\n                let successfulBuilds = buildsByMonth.builds.filter((build) => build.buildState === \"Successful\");\n                let failedBuilds = buildsByMonth.builds.filter((build) => build.buildState === \"Failed\");\n                let restartedBuilds = buildsByMonth.builds.filter((build) => build.restartCount > 0);\n                let buildsPassedFirstTime = buildsByMonth.builds.filter((build) => build.restartCount === 0 && build.buildState === \"Successful\");\n                let totalBuilds = successfulBuilds.length + failedBuilds.length;\n                let successRate = totalBuilds === 0 ? 0 : successfulBuilds.length / totalBuilds;\n                buildsByMonth.totalBuilds = totalBuilds;\n                buildsByMonth.averageBuildTime =\n                    buildsByMonth.builds.reduce((acc, build) => acc + build.buildDurationInMinutes, 0) / buildsByMonth.builds.length;\n                buildsByMonth.passBuilds = successfulBuilds.length;\n                buildsByMonth.restartedBuilds = restartedBuilds.length;\n                buildsByMonth.passFirstTimeBuilds = buildsPassedFirstTime.length;\n                buildsByMonth.successRate = successRate;\n                buildsByMonth.failureRate = 1 - successRate;\n                buildsByMonth.restartRate =\n                    totalBuilds === 0 ? 0 : restartedBuilds.length / totalBuilds;\n                buildsByMonth.passFirstTimeRate =\n                    totalBuilds === 0 ? 0 : buildsPassedFirstTime.length / totalBuilds;\n            });\n            arrayOfBuildsByMonth.sort((a, b) => {\n                return a.month.localeCompare(b.month);\n            });\n            return arrayOfBuildsByMonth;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/BambooGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/BottleneckDetectorGraphManager.ts":
/*!********************************************************************!*\
  !*** ./src/server/graphManagers/BottleneckDetectorGraphManager.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BottleneckDetectorGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass BottleneckDetectorGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getBottleneckData(project, jql) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log(`BottleneckDetectorGraphManager: Executing JQL query for project ${project}: ${jql}`);\n                // Execute real JQL query through Jira API using the faster LiteJira method\n                const issues = yield this.jiraRequester.getLiteQuery(jql);\n                // The getLiteQuery already returns LiteJiraIssue format, so no transformation needed\n                return issues;\n            }\n            catch (error) {\n                console.error(\"Error in BottleneckDetectorGraphManager.getBottleneckData:\", error);\n                throw error;\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/BottleneckDetectorGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/BugsAnalysisGraphManager.ts":
/*!**************************************************************!*\
  !*** ./src/server/graphManagers/BugsAnalysisGraphManager.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BugsAnalysisGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass BugsAnalysisGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getBugsAnalysisData(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"BugsAnalysisGraphManager: Processing query:\", query);\n            try {\n                // Fetch issues from Jira\n                const jiraIssues = yield this.jiraRequester.getQuery(query);\n                console.log(`BugsAnalysisGraphManager: Found ${jiraIssues.length} issues`);\n                // Convert to BugsAnalysisIssue format\n                const issues = jiraIssues.map((jira) => {\n                    const domain = process.env.JIRA_DOMAIN;\n                    return {\n                        key: jira.getKey(),\n                        summary: jira.getSummary(),\n                        type: jira.getType(),\n                        status: jira.getStatus(),\n                        created: jira.fields.created,\n                        resolved: jira.getResolution() ? jira.fields.resolutiondate : null,\n                        timeSpent: jira.getTimeSpent(),\n                        url: jira.getUrl(),\n                    };\n                });\n                // Group by quarter\n                const quarterlyData = this.groupByQuarter(issues);\n                return {\n                    issues,\n                    quarterlyData,\n                };\n            }\n            catch (error) {\n                console.error(\"Error fetching bugs analysis data:\", error);\n                throw error;\n            }\n        });\n    }\n    groupByQuarter(issues) {\n        const quarterMap = new Map();\n        issues.forEach((issue) => {\n            const createdDate = new Date(issue.created);\n            const quarter = this.getQuarter(createdDate);\n            if (!quarterMap.has(quarter)) {\n                quarterMap.set(quarter, {\n                    quarter,\n                    resolved: 0,\n                    unresolved: 0,\n                    resolvedIssues: [],\n                    unresolvedIssues: [],\n                    averageTimeSpent: null,\n                });\n            }\n            const quarterData = quarterMap.get(quarter);\n            const isResolved = issue.resolved !== null;\n            if (isResolved) {\n                quarterData.resolved++;\n                quarterData.resolvedIssues.push(issue);\n            }\n            else {\n                quarterData.unresolved++;\n                quarterData.unresolvedIssues.push(issue);\n            }\n        });\n        // Calculate average time spent for each quarter\n        quarterMap.forEach((quarterData) => {\n            const resolvedWithTimeSpent = quarterData.resolvedIssues.filter((issue) => issue.timeSpent !== null && issue.timeSpent > 0);\n            if (resolvedWithTimeSpent.length > 0) {\n                const totalTimeSpent = resolvedWithTimeSpent.reduce((sum, issue) => sum + (issue.timeSpent || 0), 0);\n                quarterData.averageTimeSpent = totalTimeSpent / resolvedWithTimeSpent.length;\n            }\n        });\n        // Convert to array and sort by quarter\n        return Array.from(quarterMap.values()).sort((a, b) => a.quarter.localeCompare(b.quarter));\n    }\n    getQuarter(date) {\n        const year = date.getFullYear();\n        const month = date.getMonth(); // 0-11\n        const quarter = Math.floor(month / 3) + 1;\n        return `${year}-Q${quarter}`;\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/BugsAnalysisGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/BurnupGraphManager.ts":
/*!********************************************************!*\
  !*** ./src/server/graphManagers/BurnupGraphManager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BurnupGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass BurnupGraphManager {\n    constructor(jiraRequester, sendProgress) {\n        this.lastProgress = {\n            current: 0,\n            total: 0,\n            currentEpic: \"\",\n            totalEpics: 0,\n            totalIssues: 0,\n            totalJiraRequests: 0,\n            currentJiraRequest: 0,\n        };\n        this.jiraRequester = jiraRequester;\n        this.sendProgress = sendProgress || (() => { });\n    }\n    updateProgress(step, message, progress) {\n        // Keep track of the last progress data\n        if (progress) {\n            this.lastProgress = Object.assign(Object.assign({}, this.lastProgress), progress);\n        }\n        this.sendProgress({\n            status: \"processing\",\n            step: step,\n            message,\n            progress: this.lastProgress,\n        });\n    }\n    getEpicBurnupsToDate(epics) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield Promise.all(epics.map((jira) => this.getBurnupChart(jira)));\n        });\n    }\n    getBurnupChart(epic) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let burnupArrayData = yield this.getBurnupArrayToDate(epic);\n            let burnupArray = burnupArrayData.data;\n            let startDate = epic.getEpicStartDate() || epic.getCreated();\n            let today = new Date();\n            let daysBetween = Math.floor((today.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n            let finalDoneCount = burnupArray[burnupArray.length - 1].doneDevCount || 0;\n            let finalDoneEstimate = burnupArray[burnupArray.length - 1].doneDevEstimate || 0;\n            let finalScopeCount = burnupArray[burnupArray.length - 1].scopeDevCount || 0;\n            let doneDevCountIncrement = finalDoneCount / daysBetween;\n            let doneDevEstimateIncrement = finalDoneEstimate / daysBetween;\n            return {\n                key: epic.getKey(),\n                summary: epic.getSummary(),\n                startDate: epic.getEpicStartDate() || epic.getCreated(),\n                endDate: epic.getEpicDueDate() || new Date(),\n                doneDevCountIncrement,\n                doneDevCountLimit: burnupArrayData.totalCount, //this seems wrong\n                doneDevEstimateIncrement,\n                doneDevEstimateLimit: burnupArrayData.totalEstimate, // this seems wrong\n                doneTestCountIncrement: 0, // Assuming no test items in the initial implementation\n                doneTestCountLimit: 0, // Assuming no test items in the initial implementation\n                doneTestEstimateIncrement: 0, // Assuming no test items in the initial implementation\n                doneTestEstimateLimit: 0, // Assuming no test items in the initial implementation\n                dateData: burnupArray,\n                allJiraInfo: burnupArrayData.allChildJiras.map((jira) => {\n                    return {\n                        key: jira.getKey(),\n                        summary: jira.getSummary(),\n                        url: jira.getUrl(),\n                        status: jira.getStatus(),\n                        originalEstimate: jira.getOriginalEstimate(),\n                        timeSpent: jira.getTimeSpent(),\n                        type: jira.getType(),\n                    };\n                }),\n            };\n        });\n    }\n    getEpicsFromQuery(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.jiraRequester.getQuery(query);\n        });\n    }\n    getAllEpicsUnderIssue(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const issue = yield this.jiraRequester.getFullJiraDataFromKeys([{ key }]);\n            if (!issue || issue.length === 0)\n                return [];\n            const issueType = issue[0].getType();\n            if (issueType === \"Epic\") {\n                return [key];\n            }\n            // Get all children of the current issue\n            const children = yield this.jiraRequester.getQuery(`parent=${key}`);\n            const childKeys = children.map((child) => child.getKey());\n            // Recursively get all epics under each child\n            const epicPromises = childKeys.map((childKey) => this.getAllEpicsUnderIssue(childKey));\n            const epicArrays = yield Promise.all(epicPromises);\n            // Flatten the array of arrays into a single array of epic keys\n            return epicArrays.flat();\n        });\n    }\n    getEpicsFromKeys(keys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastUpdatedKeys = keys.map((key) => ({ key }));\n            let epics = yield this.jiraRequester.getFullJiraDataFromKeys(lastUpdatedKeys);\n            return yield Promise.all(epics.map((jira) => this.addChildKeysToJira(jira)));\n        });\n    }\n    getEpicBurnupData(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.updateProgress(\"initializing\", \"Starting to process burnup data...\");\n            // Get the original issue's info\n            this.updateProgress(\"getting_original_issue\", `Getting details for issue ${key}...`, {\n                currentJiraRequest: 1,\n                totalJiraRequests: 1,\n            });\n            const originalIssue = yield this.jiraRequester.getFullJiraDataFromKeys([\n                { key },\n            ]);\n            if (!originalIssue || originalIssue.length === 0) {\n                throw new Error(`Issue ${key} not found`);\n            }\n            // Find all epics under the issue\n            this.updateProgress(\"finding_epics\", \"Finding all epics under the issue...\");\n            let epicKeys = yield this.getAllEpicsUnderIssue(key);\n            this.updateProgress(\"finding_epics\", `Found ${epicKeys.length} epics`, {\n                current: 0,\n                total: epicKeys.length,\n                totalEpics: epicKeys.length,\n                currentJiraRequest: 2,\n                totalJiraRequests: 2 + epicKeys.length, // Original issue + epic details + child issues\n            });\n            // Get epic details\n            this.updateProgress(\"getting_epic_details\", \"Getting details for all epics...\");\n            let epics = yield this.getEpicsFromKeys(epicKeys);\n            // Process each epic\n            let burnupArrays = [];\n            for (let i = 0; i < epics.length; i++) {\n                const epic = epics[i];\n                this.updateProgress(\"processing_epic\", `Processing epic ${epic.getKey()} (${i + 1}/${epicKeys.length})`, {\n                    current: i + 1,\n                    total: epicKeys.length,\n                    currentEpic: epic.getKey(),\n                    totalEpics: epicKeys.length,\n                    currentJiraRequest: 3 + i,\n                    totalJiraRequests: 2 + epicKeys.length,\n                });\n                // Get all children for this epic\n                this.updateProgress(\"getting_child_issues\", `Getting child issues for epic ${epic.getKey()}...`);\n                const allChildren = yield this.getAllChildrenJiras(epic);\n                this.updateProgress(\"processing_child_issues\", `Processing ${allChildren.length} child issues for epic ${epic.getKey()}...`, {\n                    current: i + 1,\n                    total: epicKeys.length,\n                    currentEpic: epic.getKey(),\n                    currentEpicProgress: 0,\n                    totalEpics: epicKeys.length,\n                    totalIssues: allChildren.length,\n                    currentJiraRequest: 3 + i,\n                    totalJiraRequests: 2 + epicKeys.length + allChildren.length,\n                });\n                // Calculate burnup data\n                this.updateProgress(\"calculating_burnup\", `Calculating burnup data for epic ${epic.getKey()}...`);\n                const burnupData = yield this.getBurnupChart(epic);\n                burnupArrays.push(burnupData);\n            }\n            this.updateProgress(\"complete\", \"Burnup data calculation complete\");\n            return {\n                originalKey: key,\n                originalSummary: originalIssue[0].getSummary(),\n                originalType: originalIssue[0].getType(),\n                originalUrl: originalIssue[0].getUrl(),\n                epicBurnups: burnupArrays,\n            };\n        });\n    }\n    addChildKeysToJira(jira) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let childJiras = yield this.jiraRequester.getQuery(`parent=${jira.getKey()}`);\n            let childKeys = childJiras.map((child) => {\n                return { key: child.getKey(), created: child.getCreated() };\n            });\n            jira.fields.childKeys = childKeys;\n            console.log(\"Added child keys to jira\", jira.getKey(), childKeys);\n            return jira;\n        });\n    }\n    isTestIssue(jira) {\n        return (jira.getType() === \"Development - Tests (AF)\" || jira.getType() === \"Test\");\n    }\n    isStoryIssue(jira) {\n        return jira.getType() === \"Story\";\n    }\n    getBurnupArrayToDate(epic) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let startDate = epic.getEpicStartDate() || epic.getCreated();\n            let endDate = epic.getEpicDueDate() || new Date();\n            endDate.setDate(endDate.getDate() + 1);\n            let allChildJiras = yield this.getAllChildrenJiras(epic);\n            let childJiras = allChildJiras.filter((child) => child.isInScope(endDate));\n            let childJiraTotalEstimate = childJiras.reduce((sum, child) => sum + (child.getOriginalEstimate() || 0), 0);\n            let burnupArray = [];\n            let timeSpentMap = new Map(); // Track time spent per issue\n            for (let date = startDate; date <= new Date(new Date().setDate(new Date().getDate() + 1)); //Need to add one day to the end date to include changes made today\n             date.setDate(date.getDate() + 1)) {\n                let doneChildren = allChildJiras.filter((child) => child.isDone(date));\n                let inProgressChildren = allChildJiras.filter((child) => child.isDoneOrDoing(date));\n                let existingChildren = yield this.getAllChildrenJiras(epic, date);\n                let scopeChildren = existingChildren.filter((child) => child.isInScope(date));\n                // Update time spent for each child\n                allChildJiras.forEach((child) => {\n                    var _a;\n                    const changelog = ((_a = child.changelog) === null || _a === void 0 ? void 0 : _a.histories) || [];\n                    changelog.forEach((history) => {\n                        const historyDate = new Date(history.created);\n                        if (historyDate <= date) {\n                            history.items.forEach((item) => {\n                                if (item.field === \"timespent\") {\n                                    const timeSpent = parseInt(item.toString) / (3600 * 7.5); // Convert seconds to days (7.5 hours per day)\n                                    timeSpentMap.set(child.getKey(), timeSpent);\n                                }\n                            });\n                        }\n                    });\n                });\n                // Split into other, test, and story issues\n                let doneDevChildren = doneChildren.filter((child) => !this.isTestIssue(child) && !this.isStoryIssue(child));\n                let doneTestChildren = doneChildren.filter((child) => this.isTestIssue(child));\n                let doneStoryChildren = doneChildren.filter((child) => this.isStoryIssue(child));\n                let inProgressDevChildren = inProgressChildren.filter((child) => !this.isTestIssue(child) && !this.isStoryIssue(child));\n                let inProgressTestChildren = inProgressChildren.filter((child) => this.isTestIssue(child));\n                let inProgressStoryChildren = inProgressChildren.filter((child) => this.isStoryIssue(child));\n                let scopeDevChildren = scopeChildren.filter((child) => !this.isTestIssue(child) && !this.isStoryIssue(child));\n                let scopeTestChildren = scopeChildren.filter((child) => this.isTestIssue(child));\n                let scopeStoryChildren = scopeChildren.filter((child) => this.isStoryIssue(child));\n                let doneDevEstimate = doneDevChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let doneTestEstimate = doneTestChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let doneStoryEstimate = doneStoryChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let inProgressDevEstimate = inProgressDevChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let inProgressTestEstimate = inProgressTestChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let inProgressStoryEstimate = inProgressStoryChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let scopeDevEstimate = scopeDevChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let scopeTestEstimate = scopeTestChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                let scopeStoryEstimate = scopeStoryChildren.reduce((acc, child) => acc + (child.getOriginalEstimate() || 0), 0);\n                // Calculate time spent split by other, test, and story issues\n                let timeSpentDev = 0;\n                let timeSpentTest = 0;\n                let timeSpentStory = 0;\n                let totalTimeSpent = 0;\n                allChildJiras.forEach((child) => {\n                    const timeSpent = timeSpentMap.get(child.getKey()) || 0;\n                    totalTimeSpent += timeSpent;\n                    if (this.isTestIssue(child)) {\n                        timeSpentTest += timeSpent;\n                    }\n                    else if (this.isStoryIssue(child)) {\n                        timeSpentStory += timeSpent;\n                    }\n                    else {\n                        timeSpentDev += timeSpent;\n                    }\n                });\n                burnupArray.push({\n                    date: new Date(date).toISOString().split(\"T\")[0],\n                    doneDevCount: doneDevChildren.length,\n                    doneDevEstimate,\n                    doneDevKeys: doneDevChildren.map((child) => child.getKey()),\n                    doneTestCount: doneTestChildren.length,\n                    doneTestEstimate,\n                    doneTestKeys: doneTestChildren.map((child) => child.getKey()),\n                    doneStoryCount: doneStoryChildren.length,\n                    doneStoryEstimate,\n                    doneStoryKeys: doneStoryChildren.map((child) => child.getKey()),\n                    inProgressDevCount: inProgressDevChildren.length,\n                    inProgressDevEstimate,\n                    inProgressDevKeys: inProgressDevChildren.map((child) => child.getKey()),\n                    inProgressTestCount: inProgressTestChildren.length,\n                    inProgressTestEstimate,\n                    inProgressTestKeys: inProgressTestChildren.map((child) => child.getKey()),\n                    inProgressStoryCount: inProgressStoryChildren.length,\n                    inProgressStoryEstimate,\n                    inProgressStoryKeys: inProgressStoryChildren.map((child) => child.getKey()),\n                    scopeDevCount: scopeDevChildren.length,\n                    scopeDevEstimate,\n                    scopeDevKeys: scopeDevChildren.map((child) => child.getKey()),\n                    scopeTestCount: scopeTestChildren.length,\n                    scopeTestEstimate,\n                    scopeTestKeys: scopeTestChildren.map((child) => child.getKey()),\n                    scopeStoryCount: scopeStoryChildren.length,\n                    scopeStoryEstimate,\n                    scopeStoryKeys: scopeStoryChildren.map((child) => child.getKey()),\n                    timeSpentDev: timeSpentDev || null,\n                    timeSpentTest: timeSpentTest || null,\n                    timeSpentStory: timeSpentStory || null,\n                    timeSpent: totalTimeSpent || null,\n                });\n            }\n            return {\n                data: burnupArray,\n                totalCount: allChildJiras.length,\n                totalEstimate: childJiraTotalEstimate,\n                allChildJiras,\n            };\n        });\n    }\n    getAllChildrenJiras(jira, date) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let keysSet = new Set();\n            let childrenKeys = jira.getChildrenKeysFromHistories(date);\n            childrenKeys.forEach((key) => keysSet.add(key));\n            let otherKeys = jira.fields.childKeys;\n            otherKeys.forEach((keyCreatedPair) => {\n                if (date) {\n                    let created = new Date(keyCreatedPair.created);\n                    if (created < date) {\n                        keysSet.add(keyCreatedPair);\n                    }\n                }\n                else {\n                    keysSet.add(keyCreatedPair);\n                }\n            });\n            let jiras = yield this.jiraRequester.getFullJiraDataFromKeys(Array.from(keysSet));\n            return jiras;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/BurnupGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/CreatedResolvedGraphManager.ts":
/*!*****************************************************************!*\
  !*** ./src/server/graphManagers/CreatedResolvedGraphManager.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CreatedResolvedGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass CreatedResolvedGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getCreatedResolvedData(query, startDate, endDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"CreatedResolvedGraphManager: Processing query:\", query);\n            console.log(\"Date range:\", startDate, \"to\", endDate);\n            // Format dates for JQL (YYYY-MM-DD format)\n            const startDateStr = startDate.toISOString().split(\"T\")[0];\n            const endDateStr = endDate.toISOString().split(\"T\")[0];\n            // Build JQL queries for created and resolved issues\n            const createdQuery = `${query} AND created >= \"${startDateStr}\" AND created <= \"${endDateStr}\" ORDER BY created ASC`;\n            const resolvedQuery = `${query} AND resolved >= \"${startDateStr}\" AND resolved <= \"${endDateStr}\" ORDER BY resolved ASC`;\n            console.log(\"Created query:\", createdQuery);\n            console.log(\"Resolved query:\", resolvedQuery);\n            try {\n                // Fetch created and resolved issues from Jira\n                const [createdIssues, resolvedIssues] = yield Promise.all([\n                    this.jiraRequester.getQuery(createdQuery),\n                    this.jiraRequester.getQuery(resolvedQuery),\n                ]);\n                console.log(`Found ${createdIssues.length} created issues and ${resolvedIssues.length} resolved issues`);\n                // Process and group issues by date\n                const dailyData = this.processIssuesByDate(createdIssues, resolvedIssues, startDate, endDate);\n                // Calculate summary\n                const totalCreated = createdIssues.length;\n                const totalResolved = resolvedIssues.length;\n                return {\n                    dailyData,\n                    summary: {\n                        totalCreated,\n                        totalResolved,\n                        dateRange: {\n                            start: startDateStr,\n                            end: endDateStr,\n                        },\n                    },\n                };\n            }\n            catch (error) {\n                console.error(\"Error fetching data from Jira:\", error);\n                throw error;\n            }\n        });\n    }\n    processIssuesByDate(createdIssues, resolvedIssues, startDate, endDate) {\n        const dailyDataMap = new Map();\n        // Initialize all dates in the range\n        const currentDate = new Date(startDate);\n        while (currentDate <= endDate) {\n            const dateStr = currentDate.toISOString().split(\"T\")[0];\n            dailyDataMap.set(dateStr, {\n                date: dateStr,\n                createdIssues: [],\n                resolvedIssues: [],\n            });\n            currentDate.setDate(currentDate.getDate() + 1);\n        }\n        // Process created issues\n        createdIssues.forEach((issue) => {\n            const createdDate = new Date(issue.fields.created);\n            const dateStr = createdDate.toISOString().split(\"T\")[0];\n            if (dailyDataMap.has(dateStr)) {\n                dailyDataMap.get(dateStr).createdIssues.push({\n                    key: issue.key,\n                    summary: issue.fields.summary,\n                    type: issue.fields.issuetype.name,\n                    url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                });\n            }\n        });\n        // Process resolved issues\n        resolvedIssues.forEach((issue) => {\n            const resolvedDate = new Date(issue.fields.resolutiondate);\n            const dateStr = resolvedDate.toISOString().split(\"T\")[0];\n            if (dailyDataMap.has(dateStr)) {\n                dailyDataMap.get(dateStr).resolvedIssues.push({\n                    key: issue.key,\n                    summary: issue.fields.summary,\n                    type: issue.fields.issuetype.name,\n                    url: `${process.env.JIRA_DOMAIN}/browse/${issue.key}`,\n                });\n            }\n        });\n        // Convert map to array and sort by date\n        return Array.from(dailyDataMap.values()).sort((a, b) => a.date.localeCompare(b.date));\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/CreatedResolvedGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/CumulativeFlowDiagramManager.ts":
/*!******************************************************************!*\
  !*** ./src/server/graphManagers/CumulativeFlowDiagramManager.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CumulativeFlowDiagramManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass CumulativeFlowDiagramManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getCumulativeFlowDiagramData(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // First, get all issues to determine the earliest created date\n            let jiraData = yield this.jiraRequester.getQuery(query);\n            if (jiraData.length === 0) {\n                return { allStatuses: [], timeline: [] };\n            }\n            // Find the earliest created date among all issues\n            let earliestCreatedDate = new Date(Math.min(...jiraData.map(issue => issue.created.getTime())));\n            // Set end date to today\n            let endDate = new Date();\n            let timeline = yield this.getCumulativeFlowDiagramTimeline(query, earliestCreatedDate, endDate);\n            let allStatuses = new Set();\n            timeline.forEach((day) => {\n                day.statuses.forEach((status) => {\n                    allStatuses.add(status.status);\n                });\n            });\n            return { allStatuses: Array.from(allStatuses), timeline: timeline };\n        });\n    }\n    getCumulativeFlowDiagramTimeline(query, startDate, endDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let jiraData = yield this.jiraRequester.getQuery(query);\n            let dateStatuses = [];\n            for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {\n                let statuses = new Map();\n                for (let issue of jiraData) {\n                    let status = yield issue.getStatus(new Date(date));\n                    if (!statuses.has(status)) {\n                        statuses.set(status, { status: status, issues: [] });\n                    }\n                    // @ts-ignore\n                    statuses.get(status).issues.push({\n                        key: issue.getKey(),\n                        summary: issue.getSummary(),\n                        url: issue.getUrl(),\n                        status: issue.getStatus(),\n                        type: issue.getType(),\n                        originalEstimate: issue.getOriginalEstimate(),\n                        timeSpent: issue.getTimeSpent(),\n                    });\n                }\n                dateStatuses.push({\n                    date: new Date(date),\n                    statuses: Array.from(statuses.values()),\n                });\n            }\n            return dateStatuses;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/CumulativeFlowDiagramManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/CustomerSLAGraphManager.ts":
/*!*************************************************************!*\
  !*** ./src/server/graphManagers/CustomerSLAGraphManager.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CustomerSLAGraphManager)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ \"./src/server/Utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass CustomerSLAGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getCustomerSLAData(projectName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`CustomerSLAGraphManager: Processing project ${projectName}`);\n            // Build JQL query to get all issues in the project that are not Done\n            const jqlQuery = `project = \"${projectName}\" AND statusCategory != Done ORDER BY updated DESC`;\n            console.log(`CustomerSLAGraphManager: Executing JQL query: ${jqlQuery}`);\n            try {\n                // Fetch issues from Jira\n                const jiraIssues = yield this.jiraRequester.getQuery(jqlQuery);\n                console.log(`CustomerSLAGraphManager: Found ${jiraIssues.length} issues`);\n                // Convert to CustomerSLAIssue format and calculate days in current status\n                const customerSLAIssues = jiraIssues.map((jira) => {\n                    // Get current status and calculate days in current status\n                    const currentStatus = jira.getStatus();\n                    const daysInCurrentStatus = this.calculateDaysInCurrentStatus(jira);\n                    return {\n                        key: jira.getKey(),\n                        summary: jira.getSummary(),\n                        type: jira.getType(),\n                        status: currentStatus,\n                        daysInCurrentStatus: Math.round(daysInCurrentStatus * 10) / 10, // Round to 1 decimal place\n                        url: jira.getUrl(),\n                    };\n                });\n                console.log(`CustomerSLAGraphManager: Processed ${customerSLAIssues.length} issues`);\n                return customerSLAIssues;\n            }\n            catch (error) {\n                console.error(`CustomerSLAGraphManager: Error fetching data for project ${projectName}:`, error);\n                throw error;\n            }\n        });\n    }\n    getCustomerSLADataForMultipleProjects(projectNames) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`CustomerSLAGraphManager: Processing projects ${projectNames.join(\", \")}`);\n            if (projectNames.length === 0) {\n                return [];\n            }\n            // Build JQL query for multiple projects using OR condition\n            const projectConditions = projectNames\n                .map((name) => `project = \"${name}\"`)\n                .join(\" OR \");\n            const jqlQuery = `(${projectConditions}) AND statusCategory != Done ORDER BY updated DESC`;\n            console.log(`CustomerSLAGraphManager: Executing JQL query: ${jqlQuery}`);\n            try {\n                // Fetch issues from Jira\n                const jiraIssues = yield this.jiraRequester.getQuery(jqlQuery);\n                console.log(`CustomerSLAGraphManager: Found ${jiraIssues.length} issues across ${projectNames.length} projects`);\n                // Convert to CustomerSLAIssue format and calculate days in current status\n                const customerSLAIssues = jiraIssues.map((jira) => {\n                    // Get current status and calculate days in current status\n                    const currentStatus = jira.getStatus();\n                    const daysInCurrentStatus = this.calculateDaysInCurrentStatus(jira);\n                    return {\n                        key: jira.getKey(),\n                        summary: jira.getSummary(),\n                        type: jira.getType(),\n                        status: currentStatus,\n                        daysInCurrentStatus: Math.round(daysInCurrentStatus * 10) / 10, // Round to 1 decimal place\n                        url: jira.getUrl(),\n                    };\n                });\n                console.log(`CustomerSLAGraphManager: Processed ${customerSLAIssues.length} issues from multiple projects`);\n                return customerSLAIssues;\n            }\n            catch (error) {\n                console.error(`CustomerSLAGraphManager: Error fetching data for projects ${projectNames.join(\", \")}:`, error);\n                throw error;\n            }\n        });\n    }\n    calculateDaysInCurrentStatus(jira) {\n        const currentStatus = jira.getStatus();\n        const statusChanges = jira.statusChanges;\n        // Find the most recent change to the current status\n        let lastStatusChangeDate = jira.getCreated();\n        // Look through status changes in reverse to find the most recent change to current status\n        for (let i = statusChanges.length - 1; i >= 0; i--) {\n            if (statusChanges[i].status === currentStatus) {\n                lastStatusChangeDate = statusChanges[i].date;\n                break;\n            }\n        }\n        // If we didn't find a status change to current status, it means the issue was created in this status\n        // In that case, use the created date\n        // Calculate business days between last status change and now\n        const now = new Date();\n        return (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getWorkDaysBetween)(lastStatusChangeDate, now);\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/CustomerSLAGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/DoraLeadTimeForChanges.ts":
/*!************************************************************!*\
  !*** ./src/server/graphManagers/DoraLeadTimeForChanges.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DoraLeadTimeForChanges)\n/* harmony export */ });\n//We need to create a class which:\n//- Requests the last X Released releases from Jira\n//- Gets all the Jiras from those releases\n//- Getting just the following Jira data, so it loads super fast:\n// - Key\n// - Summary\n// - Status\n// - Created\n// - Resolution Date\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass DoraLeadTimeForChanges {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getDoraLeadTime(projectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const releases = yield this.getLast10Releases(projectKey);\n                const fixVersions = this.getFixVersions(releases);\n                const keys = yield this.getJiraKeys(projectKey, fixVersions);\n                const jiraData = yield this.getJiraData(keys);\n                return this.mapJiraDataToReleases(releases, jiraData);\n            }\n            catch (error) {\n                console.error(\"Error fetching Dora lead time:\", error);\n                throw error;\n            }\n        });\n    }\n    getLast10Releases(projectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.jiraRequester.getReleasesFromProject(projectKey, 10);\n        });\n    }\n    getFixVersions(releases) {\n        return releases.map((release) => release.name);\n    }\n    getJiraKeys(projectKey, fixVersions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jql = fixVersions\n                .map((version) => `project=\"${projectKey}\" AND fixVersion=\"${version}\"`)\n                .join(\" OR \");\n            return yield this.jiraRequester.getJiraKeysInQuery(jql);\n        });\n    }\n    getJiraData(keys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.jiraRequester.getEssentialJiraDataFromKeys(keys.map((k) => k.key));\n        });\n    }\n    mapJiraDataToReleases(releases, jiraData) {\n        return releases.map((release) => {\n            const jirasForRelease = jiraData.filter((jira) => jira.fields.fixVersions.some((fv) => fv.name === release.name));\n            const doraLeadTime = this.calculateDoraLeadTime(release.releaseDate, jirasForRelease.map((jira) => jira.fields.resolutiondate));\n            return {\n                release: release.name,\n                resolvedDate: release.releaseDate,\n                jiras: jirasForRelease.map((jira) => ({\n                    key: jira.key,\n                    resolutiondate: jira.fields.resolutiondate,\n                })),\n                doraLeadTime,\n            };\n        });\n    }\n    calculateDoraLeadTime(releaseDate, resolvedDates) {\n        const releaseDateTime = new Date(releaseDate).getTime();\n        const leadTimes = resolvedDates\n            .map((date) => (releaseDateTime - new Date(date).getTime()) / (1000 * 60 * 60 * 24))\n            .filter((leadTime) => leadTime >= 0);\n        if (leadTimes.length === 0)\n            return 0;\n        const averageLeadTime = leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length;\n        return averageLeadTime;\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/DoraLeadTimeForChanges.ts?");

/***/ }),

/***/ "./src/server/graphManagers/EstimatesGraphManager.ts":
/*!***********************************************************!*\
  !*** ./src/server/graphManagers/EstimatesGraphManager.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EstimatesGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass EstimatesGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getEpicEstimatesData(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let jiras = yield this.jiraRequester.getQuery(query);\n            let uniqueStatuses = this.getUniqueStatuses(jiras);\n            return {\n                uniqueStatuses,\n                estimateData: jiras.map((jira) => {\n                    return {\n                        date: jira.getCreated(),\n                        key: jira.getKey(),\n                        type: jira.getType(),\n                        statusTimes: jira.getStatusDays(),\n                        originalEstimate: jira.getOriginalEstimate(),\n                        timeSpent: jira.getTimeSpent(),\n                        timeRemaining: jira.getTimeRemaining(),\n                    };\n                }),\n            };\n        });\n    }\n    getUniqueStatuses(jiras) {\n        let uniqueStatuses = new Set();\n        jiras.forEach((jira) => {\n            jira.getStatusDays().forEach((statusTime) => {\n                uniqueStatuses.add(statusTime.status);\n            });\n        });\n        return Array.from(uniqueStatuses);\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/EstimatesGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/JiraReportGraphManager.ts":
/*!************************************************************!*\
  !*** ./src/server/graphManagers/JiraReportGraphManager.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JiraReportGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// export interface JiraIssue {\n//   key: string;\n//   summary: string;\n//   type: string;\n//   status: string;\n//   children: JiraIssue[];\n//   childCount: number;\n//   originalEstimate?: number | null; // in days\n//   timeSpent?: number | null; // in days\n//   timeRemaining?: number | null; // in days\n// }\n// Cache for storing project data to avoid repeated API calls\nclass ProjectCache {\n    constructor() {\n        this.projects = new Map();\n        this.CACHE_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 1 week\n    }\n    setProjectData(projectKey, project, issues) {\n        this.projects.set(projectKey, {\n            project,\n            issues,\n            lastUpdated: new Date(),\n        });\n    }\n    getProjectData(projectKey) {\n        const cached = this.projects.get(projectKey);\n        if (!cached)\n            return null;\n        const isExpired = Date.now() - cached.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n        if (isExpired) {\n            this.projects.delete(projectKey);\n            return null;\n        }\n        return {\n            project: cached.project,\n            issues: cached.issues,\n        };\n    }\n    getAllCachedProjects() {\n        const projects = [];\n        for (const [_, data] of this.projects) {\n            const isExpired = Date.now() - data.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n            if (!isExpired) {\n                projects.push(data.project);\n            }\n        }\n        return projects;\n    }\n    clearCache() {\n        this.projects.clear();\n    }\n    // Find an issue across all cached projects\n    findIssueAcrossProjects(issueKey) {\n        for (const [projectKey, data] of this.projects) {\n            const isExpired = Date.now() - data.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n            if (isExpired)\n                continue;\n            const issue = this.findIssueRecursively(data.issues, issueKey);\n            if (issue) {\n                return { issue, projectKey };\n            }\n        }\n        return null;\n    }\n    findIssueRecursively(issues, targetKey) {\n        for (const issue of issues) {\n            if (issue.key === targetKey) {\n                return issue;\n            }\n            // Search in children\n            const foundInChildren = this.findIssueRecursively(issue.children, targetKey);\n            if (foundInChildren) {\n                return foundInChildren;\n            }\n        }\n        return null;\n    }\n}\n// Cache for storing all projects list\nclass ProjectsListCache {\n    constructor() {\n        this.projects = null;\n        this.lastUpdated = null;\n        this.CACHE_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 1 week\n    }\n    setProjects(projects) {\n        this.projects = projects;\n        this.lastUpdated = new Date();\n    }\n    getProjects() {\n        if (!this.projects || !this.lastUpdated)\n            return null;\n        const isExpired = Date.now() - this.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n        if (isExpired) {\n            this.projects = null;\n            this.lastUpdated = null;\n            return null;\n        }\n        return this.projects;\n    }\n    clearCache() {\n        this.projects = null;\n        this.lastUpdated = null;\n    }\n}\n// Cache for storing individual workstream issues with complete tree structure\nclass WorkstreamCache {\n    constructor() {\n        this.workstreams = new Map();\n        this.CACHE_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 1 week\n    }\n    setWorkstream(workstreamKey, workstream) {\n        this.workstreams.set(workstreamKey, {\n            workstream,\n            lastUpdated: new Date(),\n        });\n    }\n    getWorkstream(workstreamKey) {\n        const cached = this.workstreams.get(workstreamKey);\n        if (!cached) {\n            const cachedKeys = Array.from(this.workstreams.keys());\n            if (cachedKeys.length > 0) {\n                console.log(`WorkstreamCache miss for key: ${workstreamKey}. Keys in cache: [${cachedKeys.join(\", \")}]`);\n            }\n            else {\n                console.log(`WorkstreamCache miss for key: ${workstreamKey}. Cache is empty.`);\n            }\n            return null;\n        }\n        const isExpired = Date.now() - cached.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n        if (isExpired) {\n            this.workstreams.delete(workstreamKey);\n            return null;\n        }\n        return cached.workstream;\n    }\n    clearCache() {\n        this.workstreams.clear();\n    }\n    getCacheStatistics() {\n        const now = Date.now();\n        let expiredCount = 0;\n        let oldestTime = now;\n        let newestTime = 0;\n        for (const [_, data] of this.workstreams) {\n            const isExpired = now - data.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n            if (isExpired) {\n                expiredCount++;\n            }\n            const timestamp = data.lastUpdated.getTime();\n            if (timestamp < oldestTime)\n                oldestTime = timestamp;\n            if (timestamp > newestTime)\n                newestTime = timestamp;\n        }\n        const validEntries = this.workstreams.size - expiredCount;\n        const cacheHitRate = this.workstreams.size > 0\n            ? (validEntries / this.workstreams.size) * 100\n            : 0;\n        return {\n            totalCachedWorkstreams: this.workstreams.size,\n            cacheHitRate: Math.round(cacheHitRate * 100) / 100,\n            oldestEntry: oldestTime !== now ? new Date(oldestTime) : null,\n            newestEntry: newestTime !== 0 ? new Date(newestTime) : null,\n        };\n    }\n}\nclass JiraReportGraphManager {\n    constructor(jiraRequester, sendProgress) {\n        this.lastProgress = {\n            currentLevel: 0,\n            totalLevels: 0,\n            currentIssues: [],\n            totalIssues: 0,\n            apiCallsMade: 0,\n            totalApiCalls: 0,\n            currentPhase: \"\",\n            phaseProgress: 0,\n            phaseTotal: 0,\n        };\n        // Enhanced caching with TTL and size limits\n        this.MAX_CACHE_SIZE = 1000; // Maximum number of cached projects\n        this.CACHE_CLEANUP_INTERVAL = 10 * 60 * 1000; // 10 minutes\n        this.jiraRequester = jiraRequester;\n        this.projectCache = new ProjectCache();\n        this.projectsListCache = new ProjectsListCache();\n        this.workstreamCache = new WorkstreamCache();\n        this.sendProgress = sendProgress;\n        // Start cache cleanup interval\n        setInterval(() => this.cleanupCache(), this.CACHE_CLEANUP_INTERVAL);\n    }\n    updateProgress(step, message, progress) {\n        // Keep track of the last progress data\n        if (progress) {\n            this.lastProgress = Object.assign(Object.assign({}, this.lastProgress), progress);\n        }\n        if (this.sendProgress) {\n            this.sendProgress({\n                status: \"processing\",\n                step: step,\n                message,\n                progress: this.lastProgress,\n            });\n        }\n    }\n    // Clear architecture: Projects  Workstreams  Issues\n    getProjects() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedProjects = this.projectsListCache.getProjects();\n                if (cachedProjects) {\n                    console.log(`Using cached projects from Jira...`);\n                    return cachedProjects;\n                }\n                console.log(`Cache miss for projects, fetching from Jira...`);\n                const projects = yield this.jiraRequester.getProjects();\n                this.projectsListCache.setProjects(projects);\n                return projects;\n            }\n            catch (error) {\n                console.error(\"Error fetching projects from Jira:\", error);\n                throw error;\n            }\n        });\n    }\n    // Get workstreams for a specific project\n    getProjectWorkstreams(projectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let workstreams;\n                const cached = this.projectCache.getProjectData(projectKey);\n                if (cached) {\n                    console.log(`Using cached workstreams for project ${projectKey}`);\n                    workstreams = cached.issues;\n                }\n                else {\n                    console.log(`Cache miss for project ${projectKey}, fetching workstreams from Jira...`);\n                    const jql = `project = \"${projectKey}\" AND parent = empty ORDER BY created DESC`;\n                    workstreams = yield this.jiraRequester.getLiteQuery(jql);\n                    const projects = yield this.getProjects();\n                    const project = projects.find((p) => p.key === projectKey);\n                    if (project) {\n                        this.projectCache.setProjectData(projectKey, project, workstreams);\n                        console.log(`Cached workstreams for project ${projectKey} with ${workstreams.length} workstreams`);\n                    }\n                }\n                // For each workstream, check if a fully cached version is available\n                const workstreamsWithData = workstreams.map((workstream) => {\n                    const cachedWorkstream = this.workstreamCache.getWorkstream(workstream.key);\n                    if (cachedWorkstream) {\n                        console.log(`Returning fully cached workstream for ${workstream.key}`);\n                        // Set hasChildren based on cached data\n                        return Object.assign(Object.assign({}, cachedWorkstream), { hasChildren: cachedWorkstream.children.length > 0 });\n                    }\n                    // For non-cached workstreams, we don't know if they have children yet\n                    // Set hasChildren to null to indicate unknown state\n                    return Object.assign(Object.assign({}, workstream), { hasChildren: null });\n                });\n                return workstreamsWithData;\n            }\n            catch (error) {\n                console.error(`Error fetching workstreams for project ${projectKey}:`, error);\n                throw error;\n            }\n        });\n    }\n    // Get all issues for a specific workstream (with complete recursive data)\n    getWorkstreamIssues(workstreamKey_1, sendProgress_1) {\n        return __awaiter(this, arguments, void 0, function* (workstreamKey, sendProgress, withTimeSpentDetail = false) {\n            this.sendProgress = sendProgress;\n            try {\n                console.log(`\\n=== Fetching complete issue tree for workstream ${workstreamKey} ===`);\n                // Send initial progress update\n                this.updateProgress(\"starting\", `Starting to fetch complete issue tree for workstream ${workstreamKey}`, {\n                    currentLevel: 0,\n                    totalLevels: 0,\n                    currentIssues: [],\n                    totalIssues: 0,\n                    apiCallsMade: 0,\n                    totalApiCalls: 0,\n                    currentPhase: \"initializing\",\n                    phaseProgress: 0,\n                    phaseTotal: 1,\n                });\n                // First, try to find the workstream in our workstream cache\n                // Only use cache if we're not requesting timeSpentDetail (as time data may change)\n                const cachedWorkstream = !withTimeSpentDetail\n                    ? this.workstreamCache.getWorkstream(workstreamKey)\n                    : null;\n                if (cachedWorkstream) {\n                    console.log(`Found complete workstream ${workstreamKey} in cache, returning cached data`);\n                    // Send cache hit progress update\n                    this.updateProgress(\"cache_hit\", `Found workstream ${workstreamKey} in cache, returning cached data`, {\n                        currentPhase: \"cache_hit\",\n                        phaseProgress: 1,\n                        phaseTotal: 1,\n                    });\n                    console.log(`\\n=== RETURNING CACHED WORKSTREAM TREE STRUCTURE FOR ${workstreamKey} ===`);\n                    this.logTreeStructure(cachedWorkstream, 0);\n                    console.log(`=== END CACHED WORKSTREAM TREE STRUCTURE ===\\n`);\n                    return cachedWorkstream;\n                }\n                // If not in workstream cache, try to find in project cache\n                this.updateProgress(\"searching_cache\", `Searching for workstream ${workstreamKey} in project cache...`, {\n                    currentPhase: \"searching_cache\",\n                    phaseProgress: 0,\n                    phaseTotal: 1,\n                });\n                let issue;\n                let projectKey;\n                const cachedResult = this.findIssueInCache(workstreamKey);\n                if (cachedResult) {\n                    // Found in project cache\n                    issue = cachedResult.issue;\n                    projectKey = cachedResult.projectKey;\n                    console.log(`Found workstream ${workstreamKey} in project ${projectKey} cache, fetching all children recursively...`);\n                }\n                else {\n                    // Not found in cache, fetch directly from Jira\n                    console.log(`Workstream ${workstreamKey} not found in cache, fetching directly from Jira...`);\n                    this.updateProgress(\"fetching_from_jira\", `Workstream ${workstreamKey} not found in cache, fetching directly from Jira...`, {\n                        currentPhase: \"fetching_from_jira\",\n                        phaseProgress: 0,\n                        phaseTotal: 1,\n                    });\n                    // Fetch the workstream directly from Jira\n                    const workstreamData = yield this.jiraRequester.getEssentialJiraDataFromKeys([\n                        workstreamKey,\n                    ]);\n                    if (workstreamData.length === 0) {\n                        throw new Error(`Workstream ${workstreamKey} not found in Jira`);\n                    }\n                    const jiraIssue = workstreamData[0];\n                    issue = {\n                        key: workstreamKey,\n                        summary: jiraIssue.fields.summary || `Issue ${workstreamKey}`,\n                        type: \"Workstream\", // Assume it's a workstream if we're calling this method\n                        status: \"Unknown\",\n                        account: \"Unknown\", // Default value since EssentialJiraData doesn't have account\n                        children: [],\n                        childCount: 0,\n                        url: `${process.env.JIRA_DOMAIN}/browse/${workstreamKey}`,\n                        originalEstimate: null,\n                        timeSpent: null,\n                        timeRemaining: null,\n                        dueDate: null, // Required field\n                        epicStartDate: null, // Required field\n                        epicEndDate: null, // Required field\n                    };\n                    projectKey = \"Unknown\"; // We don't know the project for direct fetches\n                }\n                // Send progress update for starting batched approach\n                this.updateProgress(\"starting_batched\", `Starting recursive children fetch for workstream ${workstreamKey}...`, {\n                    currentPhase: \"fetching_children\",\n                    phaseProgress: 0,\n                    phaseTotal: 1,\n                });\n                // Use the batched approach to get all issues recursively\n                let workstreamWithAllIssues = yield this.getIssueWithAllChildrenBatched(issue, sendProgress);\n                // If withTimeSpentDetail is requested, fetch and populate time tracking data\n                if (withTimeSpentDetail) {\n                    this.updateProgress(\"fetching_time_detail\", `Fetching time spent detail for all issues in workstream ${workstreamKey}...`, {\n                        currentPhase: \"fetching_time_detail\",\n                        phaseProgress: 0,\n                        phaseTotal: 1,\n                    });\n                    // Extract all issue keys from the tree\n                    const extractAllJiraKeys = (issue) => {\n                        const keys = [issue.key];\n                        if (issue.children && issue.children.length > 0) {\n                            for (const child of issue.children) {\n                                keys.push(...extractAllJiraKeys(child));\n                            }\n                        }\n                        return keys;\n                    };\n                    const allJiraKeys = extractAllJiraKeys(workstreamWithAllIssues);\n                    console.log(`\\n=== TIME TRACKING DATA REQUEST ===`);\n                    console.log(`Extracted ${allJiraKeys.length} Jira keys from workstream ${workstreamKey} for time tracking data`);\n                    console.log(`Requested Jira keys:`, allJiraKeys);\n                    // Get time tracking data for all issues\n                    let timeTrackingData = {};\n                    try {\n                        timeTrackingData = yield this.jiraRequester.getTimeTrackingData(allJiraKeys);\n                        console.log(`Successfully fetched time tracking data for ${Object.keys(timeTrackingData).length} issues`);\n                        console.log(`Jira keys with time tracking data:`, Object.keys(timeTrackingData));\n                        console.log(`Jira keys WITHOUT time tracking data:`, allJiraKeys.filter(key => !(key in timeTrackingData)));\n                        // Log sample of data for first few keys\n                        const sampleKeys = Object.keys(timeTrackingData).slice(0, 5);\n                        sampleKeys.forEach(key => {\n                            console.log(`  ${key}: ${timeTrackingData[key].length} entries`);\n                        });\n                    }\n                    catch (error) {\n                        console.error(`Error fetching time tracking data for workstream ${workstreamKey}:`, error);\n                        // Continue with empty timeTrackingData - issues will have empty arrays\n                    }\n                    console.log(`=== END TIME TRACKING DATA REQUEST ===\\n`);\n                    // Recursively add timeSpentDetail to each issue in the tree\n                    const addTimeSpentDetail = (issue, depth = 0) => {\n                        const timeDetail = timeTrackingData[issue.key] || [];\n                        const hasData = timeDetail.length > 0;\n                        console.log(`${\"  \".repeat(depth)}[Level ${depth}] Issue ${issue.key}: ${hasData ? `${timeDetail.length} time entries` : \"no time data\"}`);\n                        return Object.assign(Object.assign({}, issue), { timeSpentDetail: timeDetail, children: issue.children.map((child) => addTimeSpentDetail(child, depth + 1)) });\n                    };\n                    console.log(`\\n=== Adding timeSpentDetail to all issues in tree ===`);\n                    console.log(`Total issues in timeTrackingData: ${Object.keys(timeTrackingData).length}`);\n                    console.log(`Total issues in tree: ${allJiraKeys.length}`);\n                    workstreamWithAllIssues = addTimeSpentDetail(workstreamWithAllIssues, 0);\n                    console.log(`=== Finished adding timeSpentDetail ===\\n`);\n                    this.updateProgress(\"time_detail_complete\", `Completed fetching time spent detail for workstream ${workstreamKey}`, {\n                        currentPhase: \"time_detail_complete\",\n                        phaseProgress: 1,\n                        phaseTotal: 1,\n                    });\n                }\n                // Cache the complete workstream tree (even if it has no children)\n                // Note: We don't cache when withTimeSpentDetail is true, as time data may change\n                if (!withTimeSpentDetail) {\n                    this.workstreamCache.setWorkstream(workstreamKey, workstreamWithAllIssues);\n                    console.log(`Cached complete workstream tree for ${workstreamKey} with ${workstreamWithAllIssues.children.length} immediate children`);\n                }\n                // Send completion progress update\n                this.updateProgress(\"complete\", `Completed fetching issue tree for workstream ${workstreamKey}`, {\n                    currentPhase: \"complete\",\n                    phaseProgress: 1,\n                    phaseTotal: 1,\n                });\n                console.log(`=== Completed fetching issue tree for workstream ${workstreamKey} ===\\n`);\n                return workstreamWithAllIssues;\n            }\n            catch (error) {\n                console.error(`Error fetching issues for workstream ${workstreamKey}:`, error);\n                // Send error progress update\n                this.updateProgress(\"error\", `Error fetching issues for workstream ${workstreamKey}: ${error.message}`, {\n                    currentPhase: \"error\",\n                    phaseProgress: 0,\n                    phaseTotal: 1,\n                });\n                throw error;\n            }\n        });\n    }\n    // Phase 4: Performance optimization and enhanced caching\n    getIssueWithAllChildrenBatched(issue, sendProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sendProgress = sendProgress;\n            console.log(`\\n=== Starting unified fetch for issue ${issue.key} ===`);\n            try {\n                // Phase 1: Collect all issue data and hierarchy in one go.\n                const { allIssues, hierarchy } = yield this.collectAllIssueDataAndHierarchy(issue, sendProgress);\n                // Phase 2: Build the complete tree structure from the collected data.\n                const issueWithAllChildren = this.buildTreeFromCollectedData(issue.key, allIssues, hierarchy);\n                // Set the hasChildren field based on whether this issue has children\n                issueWithAllChildren.hasChildren =\n                    issueWithAllChildren.children.length > 0;\n                console.log(`=== Completed unified fetch for issue ${issue.key} ===\\n`);\n                return issueWithAllChildren;\n            }\n            catch (error) {\n                console.error(`Error in unified fetch for issue ${issue.key}:`, error);\n                throw error;\n                // Fallback to simple approach if batched approach fails\n                // console.log(\n                //   `Falling back to simple children fetch for issue ${issue.key}`\n                // );\n                // return await this.getIssueWithSimpleChildren(issue);\n            }\n        });\n    }\n    // Fallback method for simple children fetching\n    getIssueWithSimpleChildren(issue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const children = yield this.jiraRequester.getChildrenForIssue(issue.key);\n                const childrenWithDetails = children.map((child) => ({\n                    key: child.key,\n                    summary: child.summary,\n                    type: child.type,\n                    status: child.status,\n                    account: child.account,\n                    children: [],\n                    childCount: 0,\n                    url: child.url,\n                    originalEstimate: child.originalEstimate || null,\n                    timeSpent: child.timeSpent || null,\n                    timeRemaining: child.timeRemaining || null,\n                    dueDate: child.dueDate || null,\n                    epicStartDate: child.epicStartDate || null,\n                    epicEndDate: child.epicEndDate || null,\n                }));\n                return Object.assign(Object.assign({}, issue), { children: childrenWithDetails, childCount: childrenWithDetails.length });\n            }\n            catch (error) {\n                console.error(`Error in simple children fetch for issue ${issue.key}:`, error);\n                return Object.assign(Object.assign({}, issue), { children: [], childCount: 0 });\n            }\n        });\n    }\n    cleanupCache() {\n        const now = Date.now();\n        let cleanedCount = 0;\n        for (const [projectKey, data] of this.projectCache[\"projects\"]) {\n            const isExpired = now - data.lastUpdated.getTime() >\n                this.projectCache[\"CACHE_DURATION_MS\"];\n            if (isExpired) {\n                this.projectCache[\"projects\"].delete(projectKey);\n                cleanedCount++;\n            }\n        }\n        if (cleanedCount > 0) {\n            console.log(`Cleaned up ${cleanedCount} expired cache entries`);\n        }\n        // If cache is still too large, remove oldest entries\n        if (this.projectCache[\"projects\"].size > this.MAX_CACHE_SIZE) {\n            const entries = Array.from(this.projectCache[\"projects\"].entries());\n            entries.sort((a, b) => a[1].lastUpdated.getTime() - b[1].lastUpdated.getTime());\n            const toRemove = entries.slice(0, this.projectCache[\"projects\"].size - this.MAX_CACHE_SIZE);\n            for (const [projectKey] of toRemove) {\n                this.projectCache[\"projects\"].delete(projectKey);\n            }\n            console.log(`Removed ${toRemove.length} oldest cache entries to maintain size limit`);\n        }\n    }\n    // Enhanced project issues loading with cache optimization\n    getProjectIssues(projectKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Clean up cache periodically\n                this.cleanupCache();\n                // Check cache first\n                const cached = this.projectCache.getProjectData(projectKey);\n                if (cached) {\n                    console.log(`Using cached data for project ${projectKey}`);\n                    return cached.issues;\n                }\n                console.log(`Cache miss for project ${projectKey}, fetching from Jira...`);\n                // Create a minimal JQL query to get issues for the specific project\n                const jql = `project = \"${projectKey}\" ORDER BY created DESC`;\n                // Use the new lite query method to get minimal data\n                const issues = yield this.jiraRequester.getLiteQuery(jql);\n                // Cache the results\n                const projects = yield this.getProjects();\n                const project = projects.find((p) => p.key === projectKey);\n                if (project) {\n                    this.projectCache.setProjectData(projectKey, project, issues);\n                    console.log(`Cached data for project ${projectKey} with ${issues.length} issues`);\n                }\n                return issues;\n            }\n            catch (error) {\n                console.error(`Error fetching issues for project ${projectKey}:`, error);\n                throw error;\n            }\n        });\n    }\n    // New method to get cached project data if available\n    getCachedProjectIssues(projectKey) {\n        const cached = this.projectCache.getProjectData(projectKey);\n        return cached ? cached.issues : null;\n    }\n    // New method to find an issue across all cached projects\n    findIssueInCache(issueKey) {\n        return this.projectCache.findIssueAcrossProjects(issueKey);\n    }\n    // New method to clear cache (useful for testing or manual refresh)\n    clearCache() {\n        this.projectCache.clearCache();\n        this.projectsListCache.clearCache();\n        this.workstreamCache.clearCache();\n    }\n    // New method to clear specific caches\n    clearProjectCache() {\n        this.projectCache.clearCache();\n    }\n    clearProjectsListCache() {\n        this.projectsListCache.clearCache();\n    }\n    clearWorkstreamCache() {\n        console.log(\"Clearing workstream cache\");\n        this.workstreamCache.clearCache();\n    }\n    // New method to get workstream cache statistics\n    getWorkstreamCacheStatistics() {\n        return this.workstreamCache.getCacheStatistics();\n    }\n    // Final enhancement: Get detailed statistics about the recursive fetching process\n    getCacheStatistics() {\n        const projects = this.projectCache[\"projects\"];\n        const now = Date.now();\n        if (projects.size === 0) {\n            return {\n                totalCachedProjects: 0,\n                cacheHitRate: 0,\n                totalCacheSize: 0,\n                oldestEntry: null,\n                newestEntry: null,\n                projectsListCache: {\n                    hasCachedProjects: this.projectsListCache.getProjects() !== null,\n                    lastUpdated: null,\n                },\n                workstreamCache: this.workstreamCache.getCacheStatistics(),\n            };\n        }\n        let expiredCount = 0;\n        let oldestTime = now;\n        let newestTime = 0;\n        for (const [_, data] of projects) {\n            const isExpired = now - data.lastUpdated.getTime() >\n                this.projectCache[\"CACHE_DURATION_MS\"];\n            if (isExpired) {\n                expiredCount++;\n            }\n            const timestamp = data.lastUpdated.getTime();\n            if (timestamp < oldestTime)\n                oldestTime = timestamp;\n            if (timestamp > newestTime)\n                newestTime = timestamp;\n        }\n        const validEntries = projects.size - expiredCount;\n        const cacheHitRate = projects.size > 0 ? (validEntries / projects.size) * 100 : 0;\n        // Get projects list cache info\n        const cachedProjects = this.projectsListCache.getProjects();\n        const projectsListCacheInfo = {\n            hasCachedProjects: cachedProjects !== null,\n            lastUpdated: null,\n        };\n        // Get workstream cache statistics\n        const workstreamCacheStats = this.workstreamCache.getCacheStatistics();\n        return {\n            totalCachedProjects: projects.size,\n            cacheHitRate: Math.round(cacheHitRate * 100) / 100,\n            totalCacheSize: projects.size,\n            oldestEntry: oldestTime !== now ? new Date(oldestTime) : null,\n            newestEntry: newestTime !== 0 ? new Date(newestTime) : null,\n            projectsListCache: projectsListCacheInfo,\n            workstreamCache: workstreamCacheStats,\n        };\n    }\n    // Phase 2: Recursive issue discovery\n    getIssueWithAllChildren(issueKey, sendProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sendProgress = sendProgress;\n            try {\n                // Try to find the issue in our project cache\n                const cachedResult = this.findIssueInCache(issueKey);\n                if (!cachedResult) {\n                    throw new Error(`Issue ${issueKey} not found in any cached project. Please load the project first.`);\n                }\n                const { issue, projectKey } = cachedResult;\n                console.log(`Found issue ${issueKey} in project ${projectKey}, checking if complete tree is already cached...`);\n                // Check if we already have the complete tree structure in cache\n                const completeTreeFromCache = this.findCompleteTreeInCache(issueKey);\n                if (completeTreeFromCache) {\n                    console.log(`Complete tree for issue ${issueKey} found in cache, returning cached data`);\n                    console.log(`\\n=== RETURNING CACHED TREE STRUCTURE FOR ${issueKey} ===`);\n                    this.logTreeStructure(completeTreeFromCache, 0);\n                    console.log(`=== END CACHED TREE STRUCTURE ===\\n`);\n                    return completeTreeFromCache;\n                }\n                console.log(`Complete tree for issue ${issueKey} not in cache, fetching recursively...`);\n                // Use the batched approach to fetch all children\n                const issueWithAllChildren = yield this.getIssueWithAllChildrenBatched(issue, sendProgress);\n                console.log(`\\n=== RETURNING FETCHED TREE STRUCTURE FOR ${issueKey} ===`);\n                this.logTreeStructure(issueWithAllChildren, 0);\n                console.log(`=== END FETCHED TREE STRUCTURE ===\\n`);\n                return issueWithAllChildren;\n            }\n            catch (error) {\n                console.error(`Error getting issue ${issueKey} with all children:`, error);\n                throw error;\n            }\n        });\n    }\n    // Helper method to log tree structure recursively\n    logTreeStructure(issue, depth) {\n        const indent = \"  \".repeat(depth);\n        console.log(`${indent} ${issue.key} - ${issue.summary} (${issue.type}) - ${issue.children.length} children`);\n        if (issue.children && issue.children.length > 0) {\n            for (const child of issue.children) {\n                this.logTreeStructure(child, depth + 1);\n            }\n        }\n    }\n    // New method to find complete tree structure in cache\n    findCompleteTreeInCache(issueKey) {\n        console.log(`\\n=== Searching for complete tree of issue ${issueKey} in cache ===`);\n        // Search through all cached projects\n        for (const [projectKey, data] of this.projectCache[\"projects\"]) {\n            const isExpired = Date.now() - data.lastUpdated.getTime() >\n                this.projectCache[\"CACHE_DURATION_MS\"];\n            if (isExpired) {\n                console.log(`Skipping expired project ${projectKey}`);\n                continue;\n            }\n            console.log(`Checking project ${projectKey} with ${data.issues.length} top-level issues`);\n            // Collect all issues in this project's tree recursively\n            const allIssuesInTree = this.collectAllIssuesInTree(data.issues);\n            console.log(`Project ${projectKey} contains ${allIssuesInTree.size} total issues in tree`);\n            // Check if our target issue is in this tree\n            if (allIssuesInTree.has(issueKey)) {\n                const cachedIssue = allIssuesInTree.get(issueKey);\n                console.log(`Found issue ${issueKey} in project ${projectKey} cache`);\n                console.log(`Issue ${issueKey} has ${cachedIssue.children.length} children`);\n                // Check if this issue has a complete tree (children with their own children)\n                if (this.hasCompleteTreeStructure(cachedIssue)) {\n                    console.log(`Issue ${issueKey} has complete tree structure in cache`);\n                    return cachedIssue;\n                }\n                else {\n                    console.log(`Issue ${issueKey} found but only has immediate children, not complete tree`);\n                }\n            }\n            else {\n                console.log(`Issue ${issueKey} not found in project ${projectKey}`);\n            }\n        }\n        console.log(`=== Complete tree for issue ${issueKey} not found in any cached project ===`);\n        return null;\n    }\n    // Collect all issues in a tree recursively into a Map\n    collectAllIssuesInTree(issues) {\n        const allIssues = new Map();\n        const collectRecursively = (issueList) => {\n            for (const issue of issueList) {\n                allIssues.set(issue.key, issue);\n                if (issue.children && issue.children.length > 0) {\n                    collectRecursively(issue.children);\n                }\n            }\n        };\n        collectRecursively(issues);\n        return allIssues;\n    }\n    // Check if an issue has a complete tree structure (children with their own children)\n    hasCompleteTreeStructure(issue) {\n        if (!issue.children || issue.children.length === 0) {\n            return true; // Leaf node, considered complete\n        }\n        // Check if any child has children (indicating we have a complete tree)\n        for (const child of issue.children) {\n            if (child.children && child.children.length > 0) {\n                return true; // Found a child with children, so this is a complete tree\n            }\n        }\n        // All children are leaf nodes, which means this is just immediate children\n        return false;\n    }\n    // Phase 1: Unified recursive issue discovery and data fetching\n    collectAllIssueDataAndHierarchy(rootIssue, sendProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sendProgress = sendProgress;\n            const allIssues = new Map();\n            const hierarchy = new Map();\n            let currentLevelKeys = [rootIssue.key];\n            let levelNumber = 0;\n            let totalApiCalls = 0;\n            // The root issue is already passed in with full details\n            allIssues.set(rootIssue.key, rootIssue);\n            console.log(`\\n--- Starting level-by-level collection ---`);\n            console.log(`Level ${levelNumber}: Root issues: ${currentLevelKeys.join(\", \")}`);\n            // Send initial progress update for level collection\n            this.updateProgress(\"level_collection_start\", \"Starting level-by-level collection of all issues\", {\n                currentLevel: levelNumber,\n                totalLevels: 0, // We don't know yet\n                currentIssues: currentLevelKeys,\n                totalIssues: currentLevelKeys.length,\n                apiCallsMade: 0,\n                totalApiCalls: 0,\n                currentPhase: \"level_collection\",\n                phaseProgress: 0,\n                phaseTotal: 1,\n            });\n            while (currentLevelKeys.length > 0) {\n                levelNumber++;\n                console.log(`\\n--- Processing Level ${levelNumber} ---`);\n                console.log(`Level ${levelNumber}: Fetching children for ${currentLevelKeys.length} issues: ${currentLevelKeys.join(\", \")}`);\n                // Send progress update for current level\n                this.updateProgress(\"processing_level\", `Processing Level ${levelNumber}: Fetching children for ${currentLevelKeys.length} issues`, {\n                    currentLevel: levelNumber,\n                    currentIssues: currentLevelKeys,\n                    totalIssues: currentLevelKeys.length,\n                    apiCallsMade: totalApiCalls,\n                    currentPhase: \"level_collection\",\n                    phaseProgress: levelNumber,\n                    phaseTotal: levelNumber + 1, // Estimate\n                });\n                // Make a single batch API call for all issues at this level\n                // This call now fetches all required fields, not just keys.\n                const batchStartTime = Date.now();\n                const childrenData = yield this.jiraRequester.getAllChildrenForIssues(currentLevelKeys);\n                const batchEndTime = Date.now();\n                totalApiCalls++;\n                console.log(`Level ${levelNumber}: Batch API call completed in ${batchEndTime - batchStartTime}ms`);\n                console.log(`Level ${levelNumber}: Found ${childrenData.length} total children`);\n                // Send progress update for API call completion\n                this.updateProgress(\"api_call_complete\", `Level ${levelNumber}: Batch API call completed, found ${childrenData.length} children`, {\n                    apiCallsMade: totalApiCalls,\n                    currentPhase: \"level_collection\",\n                    phaseProgress: levelNumber,\n                    phaseTotal: levelNumber + 1,\n                });\n                // Group children by their parent\n                const childrenByParent = new Map();\n                const nextLevelKeys = [];\n                for (const child of childrenData) {\n                    const parentKey = child.parentKey;\n                    if (!parentKey)\n                        continue; // Should not happen in this context\n                    if (!childrenByParent.has(parentKey)) {\n                        childrenByParent.set(parentKey, []);\n                    }\n                    childrenByParent.get(parentKey).push(child.key);\n                    nextLevelKeys.push(child.key);\n                    // Store the full child issue details\n                    if (!allIssues.has(child.key)) {\n                        allIssues.set(child.key, Object.assign(Object.assign({}, child), { children: [], childCount: 0 }));\n                    }\n                }\n                // Store this level's data\n                for (const [parentKey, childKeys] of childrenByParent) {\n                    hierarchy.set(parentKey, childKeys);\n                    console.log(`Level ${levelNumber}: ${parentKey} has ${childKeys.length} children: ${childKeys.join(\", \")}`);\n                }\n                console.log(`Level ${levelNumber}: Next level will have ${nextLevelKeys.length} issues to process`);\n                // Send progress update for level completion\n                this.updateProgress(\"level_complete\", `Level ${levelNumber} completed, next level will have ${nextLevelKeys.length} issues`, {\n                    currentLevel: levelNumber,\n                    currentIssues: nextLevelKeys,\n                    totalIssues: nextLevelKeys.length,\n                    apiCallsMade: totalApiCalls,\n                    currentPhase: \"level_collection\",\n                    phaseProgress: levelNumber,\n                    phaseTotal: levelNumber + 1,\n                });\n                // Prepare for next level\n                currentLevelKeys = nextLevelKeys;\n                // Safety check to prevent infinite loops\n                if (levelNumber > 10) {\n                    console.warn(`Reached maximum level depth (10), stopping to prevent infinite loop`);\n                    break;\n                }\n            }\n            console.log(`\\n--- Level-by-level collection completed ---`);\n            console.log(`Total API calls made: ${totalApiCalls}`);\n            console.log(`Total levels processed: ${levelNumber}`);\n            console.log(`Total parent-child relationships found: ${hierarchy.size}`);\n            // Send final progress update for level collection\n            this.updateProgress(\"level_collection_complete\", `Level-by-level collection completed: ${totalApiCalls} API calls, ${levelNumber} levels, ${hierarchy.size} relationships`, {\n                currentLevel: levelNumber,\n                totalLevels: levelNumber,\n                currentIssues: [],\n                totalIssues: 0,\n                apiCallsMade: totalApiCalls,\n                totalApiCalls: totalApiCalls,\n                currentPhase: \"level_collection_complete\",\n                phaseProgress: 1,\n                phaseTotal: 1,\n            });\n            return { allIssues, hierarchy };\n        });\n    }\n    // Phase 2: Simplified tree building from pre-fetched data\n    buildTreeFromCollectedData(rootIssueKey, allIssues, hierarchy) {\n        const buildRecursively = (issueKey) => {\n            const issueData = allIssues.get(issueKey);\n            if (!issueData) {\n                // This should not happen if data collection was successful\n                console.error(`Data for issue ${issueKey} was not collected.`);\n                throw `Data for issue ${issueKey} was not collected`;\n            }\n            const childKeys = hierarchy.get(issueKey) || [];\n            const children = childKeys.map((key) => buildRecursively(key));\n            // Return a copy of the issue data with the children populated\n            return Object.assign(Object.assign({}, issueData), { children, childCount: children.length });\n        };\n        console.log(`\\n--- Building tree structure for issue ${rootIssueKey} ---`);\n        const fullTree = buildRecursively(rootIssueKey);\n        console.log(`--- Tree structure completed for issue ${rootIssueKey} ---`);\n        return fullTree;\n    }\n    // Helper method to get a specific level of children for an issue\n    getIssueChildren(issueKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // First, try to find the issue in our cache\n                const cachedResult = this.findIssueInCache(issueKey);\n                if (!cachedResult) {\n                    throw new Error(`Issue ${issueKey} not found in any cached project. Please load the project first.`);\n                }\n                // Fetch immediate children for this issue\n                const children = yield this.jiraRequester.getChildrenForIssue(issueKey);\n                // Convert to JiraIssue format\n                return children.map((child) => ({\n                    key: child.key,\n                    summary: child.summary,\n                    type: child.type,\n                    status: child.status,\n                    account: child.account,\n                    children: [], // We don't fetch nested children here\n                    childCount: 0, // We don't know the child count without fetching\n                    url: child.url,\n                    originalEstimate: child.originalEstimate || null,\n                    timeSpent: child.timeSpent || null,\n                    timeRemaining: child.timeRemaining || null,\n                    dueDate: child.dueDate || null,\n                    epicStartDate: child.epicStartDate || null,\n                    epicEndDate: child.epicEndDate || null,\n                    links: child.links || [],\n                }));\n            }\n            catch (error) {\n                console.error(`Error getting children for issue ${issueKey}:`, error);\n                throw error;\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/JiraReportGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/LeadTimeGraphManager.ts":
/*!**********************************************************!*\
  !*** ./src/server/graphManagers/LeadTimeGraphManager.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LeadTimeGraphManager)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ \"./src/server/Utils.ts\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs */ \"dayjs\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass LeadTimeGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getLeadTimeIssueInfo(jira) {\n        return {\n            key: jira.getKey(),\n            summary: jira.getSummary(),\n            status: jira.getStatus(),\n            type: jira.getType(),\n            created: jira.getCreated().toISOString(),\n            resolved: jira.getResolved().toISOString(),\n            resolution: jira.getResolution(),\n            epicKey: jira.getEpicKey(),\n            epicName: jira.getEpicName(),\n            initiativeKey: jira.getInitiativeKey(),\n            initiativeName: jira.getInitiativeName(),\n            labels: jira.getLabels(),\n            priority: jira.getPriority(),\n            components: jira.getComponents(),\n            fixVersions: jira.getFixVersions(),\n            url: jira.getUrl(),\n            timeoriginalestimate: jira.getOriginalEstimate(),\n            timespent: jira.getTimeSpent(),\n            statusTimes: jira.getStatusDays(),\n            account: jira.getAccount(),\n        };\n    }\n    getQuery(filter, currentSprintStartDate, numberOfSprints) {\n        let resolvedDate = dayjs__WEBPACK_IMPORTED_MODULE_1___default()(currentSprintStartDate);\n        resolvedDate = resolvedDate.subtract(2 * numberOfSprints, \"week\");\n        let query = filter +\n            ' AND status=\"Done\" AND resolved >= ' +\n            resolvedDate.format(\"YYYY-MM-DD\");\n        return query;\n    }\n    getLeadTimeData(filter, currentSprintStartDate, numberOfSprints) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let modifiedQuery = this.getQuery(filter, currentSprintStartDate, numberOfSprints);\n            let jiras = yield this.jiraRequester.getQuery(modifiedQuery);\n            let jirasBySprint = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getIssuesBySprint)(jiras, currentSprintStartDate);\n            return {\n                sprints: jirasBySprint.map((sprintIssueList) => {\n                    return {\n                        sprintStartingDate: sprintIssueList.sprintStartingDate,\n                        issues: sprintIssueList.issues.map((jira) => this.getLeadTimeIssueInfo(jira)),\n                    };\n                }),\n            };\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/LeadTimeGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/TempoReportGraphManager.ts":
/*!*************************************************************!*\
  !*** ./src/server/graphManagers/TempoReportGraphManager.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TempoReportGraphManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass TempoReportGraphManager {\n    constructor() {\n        this.tempoToken = process.env.TEMPO_API_TOKEN || \"\";\n        this.tempoBaseUrl = \"https://api.tempo.io\";\n    }\n    getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const allAccounts = [];\n                let hasMorePages = true;\n                let offset = 0;\n                const limit = 1000; // Increased from 50 to 1000 for better performance\n                let pageCount = 0;\n                console.log(\"Starting pagination fetch for Tempo accounts...\");\n                while (hasMorePages) {\n                    pageCount++;\n                    console.log(`\\n--- Page ${pageCount} ---`);\n                    console.log(`Making API call: /4/accounts?limit=${limit}&offset=${offset}`);\n                    // Use proper pagination parameters according to Tempo API docs\n                    const response = yield this.makeTempoApiCall(`/4/accounts?limit=${limit}&offset=${offset}`);\n                    console.log(\"Raw API response:\", JSON.stringify(response, null, 2));\n                    console.log(\"Response type:\", typeof response);\n                    console.log(\"Is response an array?\", Array.isArray(response));\n                    // Handle different possible response structures\n                    let accounts;\n                    let totalCount = 0;\n                    let currentPageSize = 0;\n                    if (Array.isArray(response)) {\n                        // Direct array response (no pagination metadata)\n                        console.log(\"Detected: Direct array response (no pagination)\");\n                        accounts = response;\n                        currentPageSize = accounts.length;\n                        hasMorePages = false; // If it's a direct array, assume no pagination\n                    }\n                    else if (response &&\n                        response.metadata &&\n                        Array.isArray(response.results)) {\n                        // Tempo API paginated response with metadata and results\n                        console.log(\"Detected: Tempo API paginated response with metadata\");\n                        accounts = response.results;\n                        currentPageSize = accounts.length;\n                        totalCount = response.metadata.count || 0;\n                        // Check if there's a next page URL\n                        hasMorePages = !!response.metadata.next;\n                        console.log(\"Metadata:\", response.metadata);\n                    }\n                    else if (response && Array.isArray(response.results)) {\n                        // Paginated response with results array\n                        console.log(\"Detected: Paginated response with results array\");\n                        accounts = response.results;\n                        currentPageSize = accounts.length;\n                        totalCount = response.totalCount || response.total || 0;\n                        hasMorePages = offset + currentPageSize < totalCount;\n                    }\n                    else if (response && Array.isArray(response.data)) {\n                        // Paginated response with data array\n                        console.log(\"Detected: Paginated response with data array\");\n                        accounts = response.data;\n                        currentPageSize = accounts.length;\n                        totalCount = response.totalCount || response.total || 0;\n                        hasMorePages = offset + currentPageSize < totalCount;\n                    }\n                    else if (response &&\n                        response.values &&\n                        Array.isArray(response.values)) {\n                        // Paginated response with values array\n                        console.log(\"Detected: Paginated response with values array\");\n                        accounts = response.values;\n                        currentPageSize = accounts.length;\n                        totalCount = response.totalCount || response.total || 0;\n                        hasMorePages = offset + currentPageSize < totalCount;\n                    }\n                    else {\n                        console.error(\"Unexpected response structure:\", response);\n                        throw new Error(\"Unexpected API response structure\");\n                    }\n                    console.log(`Accounts in this page: ${currentPageSize}`);\n                    console.log(`Total count from API: ${totalCount}`);\n                    console.log(`Current offset: ${offset}`);\n                    console.log(`Has more pages: ${hasMorePages}`);\n                    // Transform the accounts from this page\n                    const transformedAccounts = accounts.map((account) => {\n                        var _a, _b, _c;\n                        return ({\n                            id: account.id,\n                            key: account.key,\n                            name: account.name,\n                            status: account.status,\n                            category: (_a = account.category) === null || _a === void 0 ? void 0 : _a.name,\n                            customer: (_b = account.customer) === null || _b === void 0 ? void 0 : _b.name,\n                            lead: (_c = account.lead) === null || _c === void 0 ? void 0 : _c.accountId, // Note: lead is an accountId, not displayName\n                            description: account.description,\n                        });\n                    });\n                    console.log(`Transformed ${transformedAccounts.length} accounts from this page`);\n                    allAccounts.push(...transformedAccounts);\n                    // Move to next page\n                    offset += currentPageSize;\n                    console.log(`New offset for next page: ${offset}`);\n                    // Safety check to prevent infinite loops\n                    if (offset > 10000) {\n                        console.warn(\"Pagination safety limit reached, stopping at 10,000 accounts\");\n                        break;\n                    }\n                }\n                console.log(`\\n=== Pagination Complete ===`);\n                console.log(`Total pages fetched: ${pageCount}`);\n                console.log(`Total accounts collected: ${allAccounts.length}`);\n                return allAccounts;\n            }\n            catch (error) {\n                console.error(\"Error fetching accounts from Tempo API:\", error);\n                throw error; // Re-throw the error instead of falling back to dummy data\n            }\n        });\n    }\n    getWorklogs(startDate, endDate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Implement real Tempo worklogs API call\n            // This will be implemented in the next phase\n            return [];\n        });\n    }\n    getWorklogsByAccount(accountKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            try {\n                const allWorklogs = [];\n                let hasMorePages = true;\n                let offset = 0;\n                const limit = 1000; // Increased from 50 to 1000 for better performance\n                let pageCount = 0;\n                console.log(`Starting pagination fetch for Tempo worklogs for account: ${accountKey}`);\n                while (hasMorePages) {\n                    pageCount++;\n                    console.log(`\\n--- Worklogs Page ${pageCount} ---`);\n                    console.log(`Making API call: /4/worklogs/account/${accountKey}?limit=${limit}&offset=${offset}`);\n                    const response = (yield this.makeTempoApiCall(`/4/worklogs/account/${accountKey}?limit=${limit}&offset=${offset}`));\n                    console.log(\"Raw worklogs API response:\", JSON.stringify(response, null, 2));\n                    if (!response || !response.results) {\n                        console.error(\"Unexpected worklogs response structure:\", response);\n                        throw new Error(\"Unexpected worklogs API response structure\");\n                    }\n                    const worklogs = response.results;\n                    const currentPageSize = worklogs.length;\n                    const totalCount = ((_a = response.metadata) === null || _a === void 0 ? void 0 : _a.count) || 0;\n                    console.log(`Worklogs in this page: ${currentPageSize}`);\n                    console.log(`Total count from API: ${totalCount}`);\n                    console.log(`Current offset: ${offset}`);\n                    // Check if there's a next page\n                    hasMorePages = !!((_b = response.metadata) === null || _b === void 0 ? void 0 : _b.next);\n                    console.log(`Has more pages: ${hasMorePages}`);\n                    allWorklogs.push(...worklogs);\n                    // Move to next page\n                    offset += currentPageSize;\n                    console.log(`New offset for next page: ${offset}`);\n                    // Safety check to prevent infinite loops\n                    if (offset > 10000) {\n                        console.warn(\"Pagination safety limit reached, stopping at 10,000 worklogs\");\n                        break;\n                    }\n                }\n                console.log(`\\n=== Worklogs Pagination Complete ===`);\n                console.log(`Total pages fetched: ${pageCount}`);\n                console.log(`Total worklogs collected: ${allWorklogs.length}`);\n                return allWorklogs;\n            }\n            catch (error) {\n                console.error(`Error fetching worklogs for account ${accountKey} from Tempo API:`, error);\n                throw error;\n            }\n        });\n    }\n    getJiraWorklogByTempoId(tempoWorklogId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log(`Converting Tempo worklog ID ${tempoWorklogId} to Jira worklog ID`);\n                // First, convert Tempo worklog ID to Jira worklog ID\n                const tempoToJiraResponse = (yield this.makeTempoApiCall(`/4/worklogs/tempo-to-jira`, {\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        tempoWorklogIds: [tempoWorklogId],\n                    }),\n                }));\n                console.log(\"Tempo to Jira conversion response:\", JSON.stringify(tempoToJiraResponse, null, 2));\n                if (!tempoToJiraResponse ||\n                    !tempoToJiraResponse.results ||\n                    tempoToJiraResponse.results.length === 0) {\n                    console.warn(`No Jira worklog found for Tempo worklog ID ${tempoWorklogId}`);\n                    return null;\n                }\n                const jiraWorklogId = tempoToJiraResponse.results[0].jiraWorklogId;\n                console.log(`Found Jira worklog ID: ${jiraWorklogId}`);\n                // Now fetch the Jira worklog details using the Jira API\n                const jiraWorklog = yield this.getJiraWorklogById(jiraWorklogId);\n                return jiraWorklog;\n            }\n            catch (error) {\n                console.error(`Error converting Tempo worklog ID ${tempoWorklogId} to Jira worklog:`, error);\n                throw error;\n            }\n        });\n    }\n    getJiraWorklogById(jiraWorklogId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // This would need to be implemented to call the Jira API\n                // For now, we'll return null as this requires Jira API integration\n                console.log(`Would fetch Jira worklog details for ID: ${jiraWorklogId}`);\n                return null;\n            }\n            catch (error) {\n                console.error(`Error fetching Jira worklog ${jiraWorklogId}:`, error);\n                return null;\n            }\n        });\n    }\n    makeTempoApiCall(endpoint, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.tempoToken) {\n                throw new Error(\"TEMPO_API_TOKEN environment variable is not set\");\n            }\n            const defaultOptions = {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${this.tempoToken}`,\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                },\n            };\n            const finalOptions = Object.assign(Object.assign({}, defaultOptions), options);\n            const response = yield fetch(`${this.tempoBaseUrl}${endpoint}`, finalOptions);\n            if (!response.ok) {\n                throw new Error(`Tempo API error: ${response.status} ${response.statusText}`);\n            }\n            return response.json();\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/TempoReportGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/ThroughputGraphManager.ts":
/*!************************************************************!*\
  !*** ./src/server/graphManagers/ThroughputGraphManager.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThroughputGraphManager)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ \"./src/server/Utils.ts\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dayjs */ \"dayjs\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass ThroughputGraphManager {\n    constructor(jiraRequester, sendProgress) {\n        this.lastProgress = {\n            current: 0,\n            total: 0,\n            totalIssues: 0,\n        };\n        this.jiraRequester = jiraRequester;\n        this.sendProgress = sendProgress || (() => { });\n    }\n    updateProgress(step, message, progress) {\n        if (progress) {\n            this.lastProgress = Object.assign(Object.assign({}, this.lastProgress), progress);\n        }\n        this.sendProgress({\n            status: \"processing\",\n            step,\n            message,\n            progress: this.lastProgress,\n        });\n    }\n    getThroughputData(filter, currentSprintStartDate, numberOfSprints) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.updateProgress(\"initializing\", \"Starting to fetch throughput data...\");\n                // Get resolved tickets\n                let resolvedQuery = this.getQuery(filter, currentSprintStartDate, numberOfSprints);\n                this.updateProgress(\"fetching\", \"Fetching resolved issues from Jira...\");\n                let resolvedJiras = yield this.jiraRequester.getQuery(resolvedQuery);\n                this.updateProgress(\"processing\", \"Processing resolved Jira issues...\", {\n                    totalIssues: resolvedJiras.length,\n                });\n                let resolvedJirasWithoutPlaceHolders = resolvedJiras.filter((jira) => jira.getSummary().indexOf(\"Placeholder\") === -1);\n                this.updateProgress(\"bucketing\", \"Organizing resolved issues by sprint...\", {\n                    totalIssues: resolvedJirasWithoutPlaceHolders.length,\n                });\n                let resolvedBucketedJiras = (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getSprintIssueListsBySprint)(resolvedJirasWithoutPlaceHolders, currentSprintStartDate);\n                // Get open tickets\n                this.updateProgress(\"fetching\", \"Fetching open issues from Jira...\");\n                let openQuery = this.getOpenTicketsQuery(filter);\n                let openJiras = yield this.jiraRequester.getQuery(openQuery);\n                this.updateProgress(\"processing\", \"Processing open Jira issues...\", {\n                    totalIssues: openJiras.length,\n                });\n                let openJirasWithoutPlaceHolders = openJiras\n                    .filter((jira) => jira.getSummary().indexOf(\"Placeholder\") === -1)\n                    .map((jira) => (0,_Utils__WEBPACK_IMPORTED_MODULE_0__.getIssueInfoFromJira)(jira));\n                this.sendProgress({\n                    status: \"complete\",\n                    data: JSON.stringify(resolvedBucketedJiras),\n                    openTickets: JSON.stringify(openJirasWithoutPlaceHolders),\n                });\n                return {\n                    resolvedTickets: resolvedBucketedJiras,\n                    openTickets: openJirasWithoutPlaceHolders,\n                };\n            }\n            catch (error) {\n                this.sendProgress({\n                    status: \"error\",\n                    message: error.message,\n                });\n                throw error;\n            }\n        });\n    }\n    getQuery(filter, currentSprintStartDate, numberOfSprints) {\n        let resolvedDate = dayjs__WEBPACK_IMPORTED_MODULE_1___default()(currentSprintStartDate);\n        resolvedDate = resolvedDate.subtract(2 * numberOfSprints, \"week\");\n        let query = filter +\n            ' AND status=\"Done\" AND resolved >= ' +\n            resolvedDate.format(\"YYYY-MM-DD\");\n        return query;\n    }\n    getOpenTicketsQuery(filter) {\n        return filter + ' AND statusCategory = \"In Progress\"';\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/ThroughputGraphManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/TimeInDevManager.ts":
/*!******************************************************!*\
  !*** ./src/server/graphManagers/TimeInDevManager.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TimeInDevManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass TimeInDevManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n    }\n    getTimeInDevData(query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let jiras = yield this.jiraRequester.getQuery(query);\n            return jiras.map((jira) => {\n                let key = jira.fields.key;\n                let summary = jira.fields.summary;\n                let url = jira.fields.url;\n                let timespent = jira.fields.timespent || 0;\n                let currentStatus = jira.fields.status.name;\n                let statuses = jira.getStatusDays();\n                return { key, summary, currentStatus, timespent, url, statuses };\n            });\n        });\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/TimeInDevManager.ts?");

/***/ }),

/***/ "./src/server/graphManagers/WorkstreamOrphanDetectorGraphManager.ts":
/*!**************************************************************************!*\
  !*** ./src/server/graphManagers/WorkstreamOrphanDetectorGraphManager.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WorkstreamOrphanDetectorGraphManager)\n/* harmony export */ });\n/* harmony import */ var _JiraReportGraphManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JiraReportGraphManager */ \"./src/server/graphManagers/JiraReportGraphManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n// Cache for storing orphan detection results\nclass OrphanDetectorCache {\n    constructor() {\n        this.cache = new Map();\n        this.CACHE_DURATION_MS = 30 * 60 * 1000; // 30 minutes\n        this.MAX_CACHE_SIZE = 50; // Maximum number of cached workstreams\n    }\n    setOrphanData(workstreamKey, workstream, linkedIssuesWithParents) {\n        this.cache.set(workstreamKey, {\n            workstream,\n            linkedIssuesWithParents,\n            lastUpdated: new Date(),\n        });\n        // Clean up if cache is too large\n        if (this.cache.size > this.MAX_CACHE_SIZE) {\n            this.cleanupOldestEntries();\n        }\n    }\n    getOrphanData(workstreamKey) {\n        const cached = this.cache.get(workstreamKey);\n        if (!cached) {\n            console.log(`OrphanDetectorCache miss for workstream: ${workstreamKey}`);\n            return null;\n        }\n        const isExpired = Date.now() - cached.lastUpdated.getTime() > this.CACHE_DURATION_MS;\n        if (isExpired) {\n            this.cache.delete(workstreamKey);\n            console.log(`OrphanDetectorCache expired for workstream: ${workstreamKey}`);\n            return null;\n        }\n        console.log(`OrphanDetectorCache hit for workstream: ${workstreamKey}`);\n        return {\n            workstream: cached.workstream,\n            linkedIssuesWithParents: cached.linkedIssuesWithParents,\n        };\n    }\n    cleanupOldestEntries() {\n        const entries = Array.from(this.cache.entries());\n        entries.sort((a, b) => a[1].lastUpdated.getTime() - b[1].lastUpdated.getTime());\n        const toRemove = entries.slice(0, entries.length - this.MAX_CACHE_SIZE);\n        for (const [workstreamKey] of toRemove) {\n            this.cache.delete(workstreamKey);\n        }\n        console.log(`OrphanDetectorCache: Removed ${toRemove.length} oldest entries`);\n    }\n    clearCache() {\n        this.cache.clear();\n        console.log(\"OrphanDetectorCache: Cache cleared\");\n    }\n    getCacheStats() {\n        return {\n            size: this.cache.size,\n            maxSize: this.MAX_CACHE_SIZE,\n            duration: this.CACHE_DURATION_MS,\n        };\n    }\n}\nclass WorkstreamOrphanDetectorGraphManager {\n    constructor(jiraRequester) {\n        this.jiraRequester = jiraRequester;\n        this.cache = new OrphanDetectorCache();\n    }\n    updateProgress(step, message, progress) {\n        if (this.sendProgress) {\n            this.sendProgress({\n                status: \"processing\",\n                step,\n                message,\n                progress: progress || {\n                    currentPhase: step,\n                    phaseProgress: 0,\n                    phaseTotal: 1,\n                    issuesProcessed: 0,\n                    totalIssues: 0,\n                    orphansFound: 0,\n                    linksProcessed: 0,\n                },\n            });\n        }\n    }\n    // Main method to detect orphans in a workstream\n    detectOrphans(workstreamKey, sendProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sendProgress = sendProgress;\n            try {\n                console.log(`\\n=== Starting Orphan Detection for Workstream ${workstreamKey} ===`);\n                // Check cache first\n                const cachedData = this.cache.getOrphanData(workstreamKey);\n                if (cachedData) {\n                    console.log(`Using cached data for workstream ${workstreamKey}`);\n                    this.updateProgress(\"complete\", `Orphan detection complete (cached data). Workstream data with links and linked issue parent trees retrieved from cache.`, {\n                        currentPhase: \"complete\",\n                        phaseProgress: 3,\n                        phaseTotal: 3,\n                        issuesProcessed: 0,\n                        totalIssues: 0,\n                        orphansFound: 0,\n                        linksProcessed: 0,\n                    });\n                    return cachedData;\n                }\n                this.updateProgress(\"initializing\", `Starting orphan detection for workstream ${workstreamKey}`, {\n                    currentPhase: \"initializing\",\n                    phaseProgress: 0,\n                    phaseTotal: 3,\n                    issuesProcessed: 0,\n                    totalIssues: 0,\n                    orphansFound: 0,\n                    linksProcessed: 0,\n                });\n                // Step 1: Get the workstream data using existing JiraReportGraphManager\n                const jiraReportGraphManager = new _JiraReportGraphManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.jiraRequester);\n                const workstreamWithChildren = yield jiraReportGraphManager.getWorkstreamIssues(workstreamKey);\n                this.updateProgress(\"fetching_linked_issues\", `Fetching linked issues and building parent trees`, {\n                    currentPhase: \"fetching_linked_issues\",\n                    phaseProgress: 1,\n                    phaseTotal: 3,\n                    issuesProcessed: 0,\n                    totalIssues: 0,\n                    orphansFound: 0,\n                    linksProcessed: 0,\n                });\n                // Step 2: Extract all linked issue keys from the workstream\n                const linkedIssueKeys = this.extractAllLinkedIssueKeysFromWorkstream(workstreamWithChildren);\n                console.log(`Found ${linkedIssueKeys.length} linked issue keys`);\n                // Step 3: Get the linked issues and build their parent trees using batched approach\n                const linkedIssuesWithParents = yield this.buildLinkedIssuesWithParentTreesBatched(linkedIssueKeys);\n                this.updateProgress(\"complete\", `Orphan detection complete. Workstream data with links and linked issue parent trees fetched.`, {\n                    currentPhase: \"complete\",\n                    phaseProgress: 2,\n                    phaseTotal: 3,\n                    issuesProcessed: 0,\n                    totalIssues: 0,\n                    orphansFound: 0,\n                    linksProcessed: 0,\n                });\n                console.log(`=== Orphan Detection Complete for Workstream ${workstreamKey} ===\\n`);\n                const result = {\n                    workstream: workstreamWithChildren,\n                    linkedIssuesWithParents,\n                };\n                // Cache the results\n                this.cache.setOrphanData(workstreamKey, workstreamWithChildren, linkedIssuesWithParents);\n                console.log(`Cached orphan detection results for workstream ${workstreamKey}`);\n                return result;\n            }\n            catch (error) {\n                console.error(`Error in orphan detection for workstream ${workstreamKey}:`, error);\n                this.updateProgress(\"error\", `Error in orphan detection: ${error.message}`, {\n                    currentPhase: \"error\",\n                    phaseProgress: 0,\n                    phaseTotal: 3,\n                    issuesProcessed: 0,\n                    totalIssues: 0,\n                    orphansFound: 0,\n                    linksProcessed: 0,\n                });\n                throw error;\n            }\n        });\n    }\n    // Extract all linked issue keys from the workstream recursively\n    extractAllLinkedIssueKeysFromWorkstream(workstream) {\n        const linkedKeys = new Set();\n        const extractFromIssue = (issue) => {\n            if (issue.links && issue.links.length > 0) {\n                for (const link of issue.links) {\n                    linkedKeys.add(link.linkedIssueKey);\n                }\n            }\n            // Recursively process children\n            for (const child of issue.children) {\n                extractFromIssue(child);\n            }\n        };\n        extractFromIssue(workstream);\n        console.log(`Extracted ${linkedKeys.size} unique linked issue keys from workstream`);\n        console.log(\"Linked keys:\", Array.from(linkedKeys));\n        return Array.from(linkedKeys);\n    }\n    // Build parent trees for linked issues using batched approach\n    buildLinkedIssuesWithParentTreesBatched(linkedIssueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (linkedIssueKeys.length === 0) {\n                return [];\n            }\n            console.log(`Building parent trees for ${linkedIssueKeys.length} linked issues using recursive batched approach`);\n            // Step 1: Get all the linked issues first\n            let currentLevelIssues = yield this.jiraRequester.getIssuesByKeys(linkedIssueKeys);\n            console.log(`Level 0: Fetched ${currentLevelIssues.length} linked issues`);\n            // Create a map to track all issues by key for easy lookup\n            const allIssuesMap = new Map();\n            currentLevelIssues.forEach((issue) => {\n                allIssuesMap.set(issue.key, issue);\n            });\n            let level = 0;\n            let hasMoreParents = true;\n            while (hasMoreParents) {\n                level++;\n                console.log(`\\n--- Level ${level}: Processing parents ---`);\n                // Step 2: Get parent keys for all issues in current level (batched)\n                const parentKeys = new Set();\n                const parentChildRelationships = yield this.getParentKeysForIssues(currentLevelIssues.map((issue) => issue.key));\n                for (const [issueKey, parentKey] of parentChildRelationships) {\n                    console.log(`Issue ${issueKey} has parent ${parentKey}`);\n                    if (parentKey) {\n                        parentKeys.add(parentKey);\n                    }\n                }\n                console.log(`Found ${parentKeys.size} unique parent keys to fetch`);\n                if (parentKeys.size === 0) {\n                    hasMoreParents = false;\n                    console.log(`No more parents to fetch - stopping at level ${level}`);\n                    break;\n                }\n                // Step 3: Fetch all parents for this level\n                const parentKeysArray = Array.from(parentKeys);\n                const parentIssues = yield this.jiraRequester.getIssuesByKeys(parentKeysArray);\n                console.log(`Level ${level}: Fetched ${parentIssues.length} parent issues`);\n                // Step 4: Add parent issues to our map\n                parentIssues.forEach((issue) => {\n                    allIssuesMap.set(issue.key, issue);\n                });\n                // Step 5: Update current level issues with their parent references\n                for (const issue of currentLevelIssues) {\n                    const parentKey = parentChildRelationships.get(issue.key);\n                    if (parentKey && allIssuesMap.has(parentKey)) {\n                        issue.parent = allIssuesMap.get(parentKey);\n                        console.log(`  ${issue.key} -> parent: ${parentKey}`);\n                    }\n                    else {\n                        issue.parent = null;\n                        console.log(`  ${issue.key} -> no parent`);\n                    }\n                }\n                // Step 6: Set up for next iteration\n                currentLevelIssues = parentIssues;\n                // Safety check to prevent infinite loops\n                if (level > 10) {\n                    console.warn(`Reached maximum level depth (10), stopping to prevent infinite loop`);\n                    break;\n                }\n            }\n            // Step 7: Return the original linked issues (now with parent trees)\n            const linkedIssuesWithParents = linkedIssueKeys\n                .map((key) => allIssuesMap.get(key))\n                .filter((issue) => issue !== undefined);\n            console.log(`Completed building parent trees for ${linkedIssuesWithParents.length} issues across ${level} levels`);\n            return linkedIssuesWithParents;\n        });\n    }\n    // Get parent keys for multiple issues in batches\n    getParentKeysForIssues(issueKeys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const parentChildMap = new Map();\n            if (issueKeys.length === 0) {\n                return parentChildMap;\n            }\n            const batchSize = 50;\n            for (let i = 0; i < issueKeys.length; i += batchSize) {\n                const batchKeys = issueKeys.slice(i, i + batchSize);\n                // Create JQL query for this batch to get parent information\n                const keyConditions = batchKeys\n                    .map((key) => `key = \"${key}\"`)\n                    .join(\" OR \");\n                const jql = `(${keyConditions})`;\n                const fields = \"key,parent\";\n                const query = `${jql}&fields=${fields}`;\n                try {\n                    const response = yield this.jiraRequester.requestDataFromServer(query);\n                    for (const issue of response.issues) {\n                        const parent = (_a = issue.fields) === null || _a === void 0 ? void 0 : _a.parent;\n                        const parentKey = parent ? parent.key : null;\n                        parentChildMap.set(issue.key, parentKey);\n                    }\n                }\n                catch (error) {\n                    console.error(`Error fetching parent relationships for batch:`, error);\n                    // Set null for all issues in this batch\n                    batchKeys.forEach((key) => parentChildMap.set(key, null));\n                }\n            }\n            return parentChildMap;\n        });\n    }\n    // Cache management methods\n    clearCache() {\n        this.cache.clearCache();\n    }\n    getCacheStats() {\n        return this.cache.getCacheStats();\n    }\n    // Method to invalidate cache for a specific workstream\n    invalidateCache(workstreamKey) {\n        // The cache will handle this automatically when we try to get expired data\n        // But we can also add explicit invalidation if needed\n        console.log(`Cache invalidation requested for workstream: ${workstreamKey}`);\n    }\n}\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/graphManagers/WorkstreamOrphanDetectorGraphManager.ts?");

/***/ }),

/***/ "./src/server/prod-server.ts":
/*!***********************************!*\
  !*** ./src/server/prod-server.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! express */ \"express\");\n/* harmony import */ var express__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(express__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dotenv */ \"dotenv\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _routes_metricsRoute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./routes/metricsRoute */ \"./src/server/routes/metricsRoute.ts\");\n\n\ndotenv__WEBPACK_IMPORTED_MODULE_1___default().config();\n\n\n// Get the project root directory (where package.json is)\nconst projectRoot = process.cwd();\nconst distPath = path__WEBPACK_IMPORTED_MODULE_2___default().join(projectRoot, 'dist');\nconst app = express__WEBPACK_IMPORTED_MODULE_0___default()();\napp.use(express__WEBPACK_IMPORTED_MODULE_0___default().json());\napp.use(express__WEBPACK_IMPORTED_MODULE_0___default().urlencoded({ extended: true }));\n// Serve static files from dist directory\napp.use(express__WEBPACK_IMPORTED_MODULE_0___default()[\"static\"](distPath));\n// API routes\napp.use('/api', _routes_metricsRoute__WEBPACK_IMPORTED_MODULE_3__.metricsRoute);\n// Serve favicon\napp.get('/favicon.svg', (req, res) => {\n    console.log('Favicon Request received ' + req.url);\n    res.sendFile(path__WEBPACK_IMPORTED_MODULE_2___default().join(distPath, 'favicon.svg'));\n});\n// Serve index.html for all other routes (SPA routing)\napp.get('*', (req, res) => {\n    console.log('Request received ' + req.url);\n    res.sendFile(path__WEBPACK_IMPORTED_MODULE_2___default().join(distPath, 'index.html'));\n});\nconst PORT = process.env.PORT || 8080;\nconst HOST = process.env.HOST || '127.0.0.1';\napp.listen(PORT, HOST, () => {\n    console.log(`Server running at http://${HOST}:${PORT}`);\n});\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/prod-server.ts?");

/***/ }),

/***/ "./src/server/routes/metricsRoute.ts":
/*!*******************************************!*\
  !*** ./src/server/routes/metricsRoute.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   metricsRoute: () => (/* binding */ metricsRoute)\n/* harmony export */ });\n/* harmony import */ var _JiraRequester__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../JiraRequester */ \"./src/server/JiraRequester.ts\");\n/* harmony import */ var _graphManagers_BurnupGraphManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphManagers/BurnupGraphManager */ \"./src/server/graphManagers/BurnupGraphManager.ts\");\n/* harmony import */ var _graphManagers_EstimatesGraphManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphManagers/EstimatesGraphManager */ \"./src/server/graphManagers/EstimatesGraphManager.ts\");\n/* harmony import */ var _graphManagers_ThroughputGraphManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphManagers/ThroughputGraphManager */ \"./src/server/graphManagers/ThroughputGraphManager.ts\");\n/* harmony import */ var _BambooRequester__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../BambooRequester */ \"./src/server/BambooRequester.ts\");\n/* harmony import */ var _graphManagers_BambooGraphManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphManagers/BambooGraphManager */ \"./src/server/graphManagers/BambooGraphManager.ts\");\n/* harmony import */ var _graphManagers_TimeInDevManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphManagers/TimeInDevManager */ \"./src/server/graphManagers/TimeInDevManager.ts\");\n/* harmony import */ var _graphManagers_LeadTimeGraphManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graphManagers/LeadTimeGraphManager */ \"./src/server/graphManagers/LeadTimeGraphManager.ts\");\n/* harmony import */ var _graphManagers_CumulativeFlowDiagramManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../graphManagers/CumulativeFlowDiagramManager */ \"./src/server/graphManagers/CumulativeFlowDiagramManager.ts\");\n/* harmony import */ var _graphManagers_DoraLeadTimeForChanges__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../graphManagers/DoraLeadTimeForChanges */ \"./src/server/graphManagers/DoraLeadTimeForChanges.ts\");\n/* harmony import */ var _graphManagers_CustomerSLAGraphManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../graphManagers/CustomerSLAGraphManager */ \"./src/server/graphManagers/CustomerSLAGraphManager.ts\");\n/* harmony import */ var _graphManagers_CreatedResolvedGraphManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../graphManagers/CreatedResolvedGraphManager */ \"./src/server/graphManagers/CreatedResolvedGraphManager.ts\");\n/* harmony import */ var _graphManagers_TempoReportGraphManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../graphManagers/TempoReportGraphManager */ \"./src/server/graphManagers/TempoReportGraphManager.ts\");\n/* harmony import */ var _graphManagers_JiraReportGraphManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../graphManagers/JiraReportGraphManager */ \"./src/server/graphManagers/JiraReportGraphManager.ts\");\n/* harmony import */ var _graphManagers_BottleneckDetectorGraphManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../graphManagers/BottleneckDetectorGraphManager */ \"./src/server/graphManagers/BottleneckDetectorGraphManager.ts\");\n/* harmony import */ var _graphManagers_WorkstreamOrphanDetectorGraphManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../graphManagers/WorkstreamOrphanDetectorGraphManager */ \"./src/server/graphManagers/WorkstreamOrphanDetectorGraphManager.ts\");\n/* harmony import */ var _graphManagers_BugsAnalysisGraphManager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../graphManagers/BugsAnalysisGraphManager */ \"./src/server/graphManagers/BugsAnalysisGraphManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst express = __webpack_require__(/*! express */ \"express\");\nconst metricsRoute = express.Router();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getJiraData(issueKey) {\n    return __awaiter(this, void 0, void 0, function* () { });\n}\nconst jiraRequester = new _JiraRequester__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nconst bambooRequester = new _BambooRequester__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\nconst burnupGraphManager = new _graphManagers_BurnupGraphManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"](jiraRequester);\nconst estimatesGraphManager = new _graphManagers_EstimatesGraphManager__WEBPACK_IMPORTED_MODULE_2__[\"default\"](jiraRequester);\nconst bambooGraphManager = new _graphManagers_BambooGraphManager__WEBPACK_IMPORTED_MODULE_5__[\"default\"](bambooRequester);\nconst timeInDevManager = new _graphManagers_TimeInDevManager__WEBPACK_IMPORTED_MODULE_6__[\"default\"](jiraRequester);\nconst leadTimeGraphManager = new _graphManagers_LeadTimeGraphManager__WEBPACK_IMPORTED_MODULE_7__[\"default\"](jiraRequester);\nconst cfdm = new _graphManagers_CumulativeFlowDiagramManager__WEBPACK_IMPORTED_MODULE_8__[\"default\"](jiraRequester);\nconst doraLeadTimeForChanges = new _graphManagers_DoraLeadTimeForChanges__WEBPACK_IMPORTED_MODULE_9__[\"default\"](jiraRequester);\nconst customerSLAGraphManager = new _graphManagers_CustomerSLAGraphManager__WEBPACK_IMPORTED_MODULE_10__[\"default\"](jiraRequester);\nconst createdResolvedGraphManager = new _graphManagers_CreatedResolvedGraphManager__WEBPACK_IMPORTED_MODULE_11__[\"default\"](jiraRequester);\nconst tempoReportGraphManager = new _graphManagers_TempoReportGraphManager__WEBPACK_IMPORTED_MODULE_12__[\"default\"]();\nconst jiraReportGraphManager = new _graphManagers_JiraReportGraphManager__WEBPACK_IMPORTED_MODULE_13__[\"default\"](jiraRequester);\nconst bottleneckDetectorGraphManager = new _graphManagers_BottleneckDetectorGraphManager__WEBPACK_IMPORTED_MODULE_14__[\"default\"](jiraRequester);\nconst workstreamOrphanDetectorGraphManager = new _graphManagers_WorkstreamOrphanDetectorGraphManager__WEBPACK_IMPORTED_MODULE_15__[\"default\"](jiraRequester);\nconst bugsAnalysisGraphManager = new _graphManagers_BugsAnalysisGraphManager__WEBPACK_IMPORTED_MODULE_16__[\"default\"](jiraRequester);\nmetricsRoute.get(\"/cumulativeFlowDiagram\", (req, res) => {\n    const query = req.query.query;\n    cfdm\n        .getCumulativeFlowDiagramData(query)\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data: JSON.stringify(data) });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\nmetricsRoute.get(\"/leadTime\", (req, res) => {\n    const query = req.query.query;\n    const currentSprintStartDate = new Date(req.query.currentSprintStartDate);\n    const numberOfSprints = parseInt(req.query.numberOfSprints);\n    leadTimeGraphManager\n        .getLeadTimeData(query, currentSprintStartDate, numberOfSprints)\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data: JSON.stringify(data) });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\nmetricsRoute.get(\"/timeInDev\", (req, res) => {\n    const query = req.query.query;\n    timeInDevManager\n        .getTimeInDevData(query)\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data: JSON.stringify(data) });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\nmetricsRoute.get(\"/bamboo\", (req, res) => {\n    const projectBuildKey = req.query.projectBuildKey;\n    bambooGraphManager\n        .getBuildDataByWeek(projectBuildKey)\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data: JSON.stringify(data) });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\nmetricsRoute.get(\"/throughput\", (req, res) => {\n    const query = req.query.query;\n    const currentSprintStartDate = new Date(req.query.currentSprintStartDate);\n    const numberOfSprints = parseInt(req.query.numberOfSprints);\n    // Set headers for SSE\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    // Create a new ThroughputGraphManager with progress callback\n    const throughputGraphManager = new _graphManagers_ThroughputGraphManager__WEBPACK_IMPORTED_MODULE_3__[\"default\"](jiraRequester, (progress) => {\n        console.log(\"Sending progress update:\", progress);\n        res.write(`data: ${JSON.stringify(progress)}\\n\\n`);\n    });\n    // Send initial processing message\n    res.write(`data: ${JSON.stringify({\n        status: \"processing\",\n        step: \"initializing\",\n        message: \"Starting to process throughput data...\",\n        progress: {\n            current: 0,\n            total: 0,\n            totalIssues: 0,\n        },\n    })}\\n\\n`);\n    throughputGraphManager\n        .getThroughputData(query, currentSprintStartDate, numberOfSprints)\n        .then((data) => {\n        // Send completion message with data\n        res.write(`data: ${JSON.stringify({\n            status: \"complete\",\n            data: JSON.stringify(data),\n        })}\\n\\n`);\n        res.end();\n    })\n        .catch((error) => {\n        console.error(\"Error:\", error);\n        res.write(`data: ${JSON.stringify({\n            status: \"error\",\n            message: error.message,\n        })}\\n\\n`);\n        res.end();\n    });\n});\nmetricsRoute.get(\"/estimates\", (req, res) => {\n    const query = req.query.query;\n    estimatesGraphManager\n        .getEpicEstimatesData(query)\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data: JSON.stringify(data) });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\nmetricsRoute.get(\"/epicBurnup\", (req, res) => {\n    const query = req.query.query;\n    // Set headers for SSE\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    // Create a new BurnupGraphManager with progress callback\n    const burnupGraphManager = new _graphManagers_BurnupGraphManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"](jiraRequester, (progress) => {\n        console.log(\"Sending progress update:\", progress);\n        res.write(`data: ${JSON.stringify(progress)}\\n\\n`);\n    });\n    // Send initial processing message\n    res.write(`data: ${JSON.stringify({\n        status: \"processing\",\n        step: \"initializing\",\n        message: \"Starting to process burnup data...\",\n        progress: {\n            current: 0,\n            total: 0,\n            currentEpic: \"\",\n            totalEpics: 0,\n            totalIssues: 0,\n        },\n    })}\\n\\n`);\n    burnupGraphManager\n        .getEpicBurnupData(query)\n        .then((data) => {\n        // Send completion message with data\n        res.write(`data: ${JSON.stringify({\n            status: \"complete\",\n            data: JSON.stringify(data),\n        })}\\n\\n`);\n        res.end();\n    })\n        .catch((error) => {\n        console.error(\"Error:\", error);\n        res.write(`data: ${JSON.stringify({\n            status: \"error\",\n            message: error.message,\n        })}\\n\\n`);\n        res.end();\n    });\n});\nmetricsRoute.get(\"/doraLeadTime\", (req, res) => {\n    const projectName = req.query.projectName;\n    doraLeadTimeForChanges\n        .getDoraLeadTime(projectName)\n        .then((data) => {\n        res.json({\n            message: \"Dora lead time fetched successfully\",\n            data: JSON.stringify(data),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error:\", error);\n        res\n            //@ts-ignore\n            .status(500)\n            .json({\n            message: \"Failed to fetch Dora lead time\",\n            error: error.message,\n        });\n    });\n});\nmetricsRoute.get(\"/customerSLA\", (req, res) => {\n    const projectNamesParam = req.query.projectNames;\n    // Handle both single project (legacy) and multiple projects\n    let projectNames;\n    if (projectNamesParam.includes(\",\")) {\n        projectNames = projectNamesParam.split(\",\").map((name) => name.trim());\n    }\n    else {\n        projectNames = [projectNamesParam];\n    }\n    console.log(`Customer SLA endpoint called for projects: ${projectNames.join(\", \")}`);\n    customerSLAGraphManager\n        .getCustomerSLADataForMultipleProjects(projectNames)\n        .then((data) => {\n        res.json({\n            message: \"Customer SLA data fetched successfully\",\n            data: JSON.stringify(data),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error:\", error);\n        res.json({\n            message: \"Error fetching Customer SLA data\",\n            data: JSON.stringify([]),\n        });\n    });\n});\nmetricsRoute.get(\"/projects\", (req, res) => {\n    console.log(\"Projects endpoint called - fetching from Jira\");\n    jiraRequester\n        .getProjects()\n        .then((projects) => {\n        console.log(`Found ${projects.length} projects from Jira`);\n        res.json({\n            message: \"Projects fetched successfully from Jira\",\n            data: JSON.stringify(projects),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error fetching projects from Jira:\", error);\n        res.json({\n            message: \"Error fetching projects from Jira\",\n            data: JSON.stringify([]),\n        });\n    });\n});\nmetricsRoute.get(\"/createdResolved\", (req, res) => {\n    const query = req.query.query;\n    const startDate = new Date(req.query.startDate);\n    const endDate = new Date(req.query.endDate);\n    createdResolvedGraphManager\n        .getCreatedResolvedData(query, startDate, endDate)\n        .then((data) => {\n        res.json({\n            message: \"Created/Resolved data fetched successfully\",\n            data: JSON.stringify(data),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error:\", error);\n        res.json({\n            message: \"Error fetching Created/Resolved data\",\n            data: JSON.stringify([]),\n        });\n    });\n});\nmetricsRoute.get(\"/tempoAccounts\", (req, res) => {\n    tempoReportGraphManager\n        .getAccounts()\n        .then((accounts) => {\n        res.json({\n            message: \"Tempo accounts data fetched successfully\",\n            data: JSON.stringify(accounts),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error fetching Tempo accounts:\", error);\n        res.json({\n            message: \"Error fetching Tempo accounts data\",\n            data: JSON.stringify([]),\n        });\n    });\n});\nmetricsRoute.get(\"/tempoWorklogs/:accountKey\", (req, res) => {\n    const accountKey = req.params.accountKey;\n    tempoReportGraphManager\n        .getWorklogsByAccount(accountKey)\n        .then((worklogs) => {\n        res.json({\n            message: \"Tempo worklogs data fetched successfully\",\n            data: JSON.stringify(worklogs),\n        });\n    })\n        .catch((error) => {\n        console.error(`Error fetching Tempo worklogs for account ${accountKey}:`, error);\n        res.json({\n            message: `Error fetching Tempo worklogs data for account ${accountKey}`,\n            data: JSON.stringify([]),\n        });\n    });\n});\nmetricsRoute.post(\"/tempoToJiraWorklog\", (req, res) => {\n    const { tempoWorklogId } = req.body;\n    if (!tempoWorklogId) {\n        res.status(400).json({\n            message: \"tempoWorklogId is required\",\n            data: JSON.stringify(null),\n        });\n        return;\n    }\n    tempoReportGraphManager\n        .getJiraWorklogByTempoId(tempoWorklogId)\n        .then((jiraWorklog) => {\n        res.json({\n            message: \"Jira worklog data fetched successfully\",\n            data: JSON.stringify(jiraWorklog),\n        });\n    })\n        .catch((error) => {\n        console.error(`Error converting Tempo worklog ID ${tempoWorklogId} to Jira worklog:`, error);\n        res.json({\n            message: `Error converting Tempo worklog ID ${tempoWorklogId} to Jira worklog`,\n            data: JSON.stringify(null),\n        });\n    });\n});\nmetricsRoute.get(\"/jiraIssue/:issueId\", (req, res) => {\n    const issueId = req.params.issueId;\n    if (!issueId) {\n        res.status(400).json({\n            message: \"issueId is required\",\n            data: JSON.stringify(null),\n        });\n        return;\n    }\n    // Use the existing JiraRequester to fetch issue data by ID\n    jiraRequester\n        .getEssentialJiraDataFromKeys([issueId])\n        .then((issues) => {\n        if (issues && issues.length > 0) {\n            res.json({\n                message: \"Jira issue data fetched successfully\",\n                data: JSON.stringify(issues[0]),\n            });\n        }\n        else {\n            res.json({\n                message: `No Jira issue found with ID ${issueId}`,\n                data: JSON.stringify(null),\n            });\n        }\n    })\n        .catch((error) => {\n        console.error(`Error fetching Jira issue ${issueId}:`, error);\n        res.json({\n            message: `Error fetching Jira issue data for ID ${issueId}`,\n            data: JSON.stringify(null),\n        });\n    });\n});\nmetricsRoute.get(\"/metrics\", (req, res) => {\n    const domain = process.env.JIRA_DOMAIN;\n    const issueKey = \"AF-1\";\n    const url = `${domain}/${issueKey}`;\n    const email = process.env.JIRA_EMAIL;\n    const apiToken = process.env.JIRA_API_TOKEN;\n    fetch(url, {\n        method: \"GET\", // or 'POST', 'PUT', etc. depending on your request\n        headers: {\n            Authorization: \"Basic \" + btoa(`${email}:${apiToken}`),\n            Accept: \"application/json\",\n        },\n    })\n        .then((response) => response.json())\n        .then((data) => {\n        res.json({ message: \"Metrics route\", data });\n    })\n        .catch((error) => console.error(\"Error:\", error));\n});\n// Real API route for Jira Report projects\nmetricsRoute.get(\"/jiraReport/projects\", (req, res) => {\n    console.log(\"Jira Report projects endpoint called - fetching from Jira\");\n    jiraReportGraphManager\n        .getProjects()\n        .then((projects) => {\n        console.log(`Found ${projects.length} projects from Jira`);\n        res.json({\n            message: \"Jira projects fetched successfully\",\n            data: JSON.stringify(projects),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error fetching projects from Jira:\", error);\n        res.json({\n            message: \"Error fetching projects from Jira\",\n            data: JSON.stringify([]),\n        });\n    });\n});\n// API route for Jira Report project workstreams\nmetricsRoute.get(\"/jiraReport/project/:projectKey/workstreams\", (req, res) => {\n    const projectKey = req.params.projectKey;\n    console.log(`Jira Report project workstreams endpoint called for project: ${projectKey}`);\n    jiraReportGraphManager\n        .getProjectWorkstreams(projectKey)\n        .then((workstreams) => {\n        console.log(`Found ${workstreams.length} workstreams for project ${projectKey}`);\n        res.json({\n            message: `Workstreams for project ${projectKey} fetched successfully`,\n            data: JSON.stringify(workstreams),\n        });\n    })\n        .catch((error) => {\n        console.error(`Error fetching workstreams for project ${projectKey}:`, error);\n        res.json({\n            message: `Error fetching workstreams for project ${projectKey}`,\n            data: JSON.stringify([]),\n        });\n    });\n});\n// API route for getting all issues in a workstream (with complete recursive data)\nmetricsRoute.get(\"/jiraReport/workstream/:workstreamKey/workstream\", (req, res) => {\n    const workstreamKey = req.params.workstreamKey;\n    const withTimeSpentDetail = req.query.withTimeSpentDetail === \"true\";\n    console.log(`Jira Report workstream endpoint called for workstream: ${workstreamKey}, withTimeSpentDetail: ${withTimeSpentDetail}`);\n    // Set headers for SSE\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    // Send initial processing message\n    res.write(`data: ${JSON.stringify({\n        status: \"processing\",\n        step: \"initializing\",\n        message: `Starting to fetch complete issue tree for workstream ${workstreamKey}...`,\n        progress: {\n            currentLevel: 0,\n            totalLevels: 0,\n            currentIssues: [],\n            totalIssues: 0,\n            apiCallsMade: 0,\n            totalApiCalls: 0,\n            currentPhase: \"initializing\",\n            phaseProgress: 0,\n            phaseTotal: 1,\n        },\n    })}\\n\\n`);\n    jiraReportGraphManager\n        .getWorkstreamIssues(workstreamKey, (progress) => {\n        res.write(`data: ${JSON.stringify(progress)}\\n\\n`);\n    }, withTimeSpentDetail)\n        .then((workstreamWithIssues) => {\n        console.log(`Fetched complete issue tree for workstream ${workstreamKey}`);\n        // Log the structure being sent to frontend\n        console.log(`\\n=== SENDING WORKSTREAM DATA TO FRONTEND FOR ${workstreamKey} ===`);\n        console.log(`Workstream: ${workstreamWithIssues.key} - ${workstreamWithIssues.summary}`);\n        console.log(`Total issues in workstream: ${workstreamWithIssues.children.length}`);\n        console.log(`=== END WORKSTREAM DATA ===\\n`);\n        // Send completion message with data\n        res.write(`data: ${JSON.stringify({\n            status: \"complete\",\n            data: JSON.stringify(workstreamWithIssues),\n            hasData: workstreamWithIssues.children.length > 0,\n        })}\\n\\n`);\n        res.end();\n    })\n        .catch((error) => {\n        console.error(`Error fetching issues for workstream ${workstreamKey}:`, error);\n        // Send error message\n        res.write(`data: ${JSON.stringify({\n            status: \"error\",\n            message: `Error fetching issues for workstream ${workstreamKey}: ${error.message}`,\n        })}\\n\\n`);\n        res.end();\n    });\n});\n// New API route for getting issue children (Phase 3)\nmetricsRoute.get(\"/jiraReport/issue/:issueKey/children\", (req, res) => {\n    const issueKey = req.params.issueKey;\n    console.log(`Jira Report issue children endpoint called for issue: ${issueKey}`);\n    jiraReportGraphManager\n        .getIssueChildren(issueKey)\n        .then((children) => {\n        console.log(`Found ${children.length} children for issue ${issueKey}`);\n        res.json({\n            message: `Children for issue ${issueKey} fetched successfully`,\n            data: JSON.stringify(children),\n        });\n    })\n        .catch((error) => {\n        console.error(`Error fetching children for issue ${issueKey}:`, error);\n        res.json({\n            message: `Error fetching children for issue ${issueKey}: ${error.message}`,\n            data: JSON.stringify([]),\n        });\n    });\n});\n// New API route for getting issue with all descendants (Phase 3)\nmetricsRoute.get(\"/jiraReport/issue/:issueKey/with-children\", (req, res) => {\n    const issueKey = req.params.issueKey;\n    console.log(`Jira Report issue with all children endpoint called for issue: ${issueKey}`);\n    jiraReportGraphManager\n        .getIssueWithAllChildren(issueKey, (progress) => {\n        // In a non-SSE context, you might log this or handle it differently\n        console.log(\"Progress update:\", progress);\n    })\n        .then((issueWithChildren) => {\n        console.log(`Fetched issue ${issueKey} with all descendants`);\n        // Log the structure being sent to frontend\n        console.log(`\\n=== SENDING TO FRONTEND FOR ${issueKey} ===`);\n        console.log(`Root issue: ${issueWithChildren.key} - ${issueWithChildren.summary}`);\n        console.log(`Total children at root level: ${issueWithChildren.children.length}`);\n        // Count total issues in the tree\n        const countIssuesInTree = (issue) => {\n            let count = 1; // Count this issue\n            if (issue.children && issue.children.length > 0) {\n                for (const child of issue.children) {\n                    count += countIssuesInTree(child);\n                }\n            }\n            return count;\n        };\n        const totalIssuesInTree = countIssuesInTree(issueWithChildren);\n        console.log(`Total issues in complete tree: ${totalIssuesInTree}`);\n        console.log(`=== END FRONTEND DATA ===\\n`);\n        res.json({\n            message: `Issue ${issueKey} with all descendants fetched successfully`,\n            data: JSON.stringify(issueWithChildren),\n        });\n    })\n        .catch((error) => {\n        console.error(`Error fetching issue ${issueKey} with all children:`, error);\n        res.json({\n            message: `Error fetching issue ${issueKey} with all children: ${error.message}`,\n            data: JSON.stringify(null),\n        });\n    });\n});\n// Bottleneck Detector API route\nmetricsRoute.get(\"/bottleneck-detector\", (req, res) => {\n    const project = req.query.project;\n    const jql = req.query.jql;\n    console.log(`Bottleneck Detector endpoint called for project: ${project} with JQL: ${jql}`);\n    bottleneckDetectorGraphManager\n        .getBottleneckData(project, jql)\n        .then((data) => {\n        res.json({\n            message: \"Bottleneck Detector data fetched successfully\",\n            data: JSON.stringify(data),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error in Bottleneck Detector API:\", error);\n        res.json({\n            message: `Error fetching Bottleneck Detector data: ${error.message}`,\n            data: JSON.stringify([]),\n        });\n    });\n});\n// Type Breakdown Analyser API route\nmetricsRoute.get(\"/typeBreakdownAnalyser\", (req, res) => {\n    const query = req.query.query;\n    console.log(`Type Breakdown Analyser endpoint called with query: ${query}`);\n    // Set headers for SSE\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    // Send initial processing message\n    res.write(`data: ${JSON.stringify({\n        status: \"processing\",\n        step: \"initializing\",\n        message: `Starting to fetch and analyse data for query: ${query}`,\n        progress: {\n            currentLevel: 0,\n            totalLevels: 0,\n            currentIssues: [],\n            totalIssues: 0,\n            apiCallsMade: 0,\n            totalApiCalls: 0,\n            currentPhase: \"initializing\",\n            phaseProgress: 0,\n            phaseTotal: 1,\n        },\n    })}\\n\\n`);\n    // Use JiraRequester to fetch issues from JQL query, then recursively fetch children\n    jiraRequester\n        .getLiteQuery(query)\n        .then((issues) => __awaiter(void 0, void 0, void 0, function* () {\n        console.log(`Type Breakdown Analyser: Found ${issues.length} issues for query: ${query}`);\n        if (issues.length === 0) {\n            res.write(`data: ${JSON.stringify({\n                status: \"complete\",\n                data: JSON.stringify({\n                    key: \"query-results\",\n                    summary: `Query Results: ${query}`,\n                    type: \"Query\",\n                    status: \"Complete\",\n                    children: [],\n                    childCount: 0,\n                    url: \"\",\n                    originalEstimate: null,\n                    timeSpent: null,\n                    timeRemaining: null,\n                    dueDate: null,\n                    epicStartDate: null,\n                    epicEndDate: null,\n                }),\n                hasData: false,\n            })}\\n\\n`);\n            res.end();\n            return;\n        }\n        // Send progress update\n        res.write(`data: ${JSON.stringify({\n            status: \"processing\",\n            step: \"fetching_children\",\n            message: `Found ${issues.length} issues, now fetching children recursively...`,\n            progress: {\n                currentLevel: 1,\n                totalLevels: 1,\n                currentIssues: issues.map((i) => i.key),\n                totalIssues: issues.length,\n                apiCallsMade: 1,\n                totalApiCalls: 1,\n                currentPhase: \"fetching_children\",\n                phaseProgress: 0,\n                phaseTotal: 1,\n            },\n        })}\\n\\n`);\n        // For each issue, fetch its children recursively using the JiraReportGraphManager\n        const issuesWithChildren = [];\n        for (let i = 0; i < issues.length; i++) {\n            const issue = issues[i];\n            try {\n                // Use the existing recursive fetching method for each issue\n                const issueWithChildren = yield jiraReportGraphManager.getWorkstreamIssues(issue.key, (progress) => {\n                    // Forward progress updates\n                    res.write(`data: ${JSON.stringify(progress)}\\n\\n`);\n                });\n                issuesWithChildren.push(issueWithChildren);\n            }\n            catch (error) {\n                console.error(`Error fetching children for issue ${issue.key}:`, error);\n                // Add the issue without children if fetching fails\n                issuesWithChildren.push(Object.assign(Object.assign({}, issue), { children: [], childCount: 0 }));\n            }\n        }\n        // Create a root container with all the issues as children\n        const rootData = {\n            key: \"query-results\",\n            summary: `Query Results: ${query}`,\n            type: \"Query\",\n            status: \"Complete\",\n            children: issuesWithChildren,\n            childCount: issuesWithChildren.length,\n            url: \"\",\n            originalEstimate: null,\n            timeSpent: null,\n            timeRemaining: null,\n            dueDate: null,\n            epicStartDate: null,\n            epicEndDate: null,\n        };\n        console.log(`Type Breakdown Analyser: Completed fetching data for query: ${query}`);\n        console.log(`Root data:`, rootData);\n        // Send completion message with data\n        res.write(`data: ${JSON.stringify({\n            status: \"complete\",\n            data: JSON.stringify(rootData),\n            hasData: issuesWithChildren.length > 0,\n        })}\\n\\n`);\n        res.end();\n    }))\n        .catch((error) => {\n        console.error(`Error in Type Breakdown Analyser for query ${query}:`, error);\n        // Send error message\n        res.write(`data: ${JSON.stringify({\n            status: \"error\",\n            message: `Error analysing data for query ${query}: ${error.message}`,\n        })}\\n\\n`);\n        res.end();\n    });\n});\n// Account Worklogs by Month API route\nmetricsRoute.get(\"/jiraReport/account/:account/worklogs/:year/:month\", (req, res) => __awaiter(void 0, void 0, void 0, function* () {\n    const account = req.params.account;\n    const year = parseInt(req.params.year);\n    const month = parseInt(req.params.month);\n    console.log(`Account worklogs endpoint called for account: ${account}, year: ${year}, month: ${month}`);\n    if (isNaN(year) || isNaN(month) || month < 1 || month > 12) {\n        res.json({\n            message: \"Invalid year or month parameter\",\n            data: JSON.stringify({\n                error: \"Year must be a number and month must be between 1 and 12\",\n            }),\n        });\n        return;\n    }\n    try {\n        console.log(`Starting worklog fetch for account: ${account}, year: ${year}, month: ${month}`);\n        const worklogs = yield jiraRequester.getWorklogsForAccountMonth(account, year, month);\n        console.log(`Retrieved ${worklogs.length} worklogs from JiraRequester`);\n        // Calculate summary statistics\n        const totalTimeSpent = worklogs.reduce((sum, worklog) => sum + worklog.timeSpentSeconds, 0);\n        const uniqueIssues = new Set(worklogs.map((w) => w.issueKey)).size;\n        const uniqueAuthors = new Set(worklogs.map((w) => w.author)).size;\n        console.log(`Summary: ${worklogs.length} worklogs, ${uniqueIssues} unique issues, ${uniqueAuthors} unique authors, ${totalTimeSpent} total seconds`);\n        const summary = {\n            totalWorklogs: worklogs.length,\n            totalTimeSpentSeconds: totalTimeSpent,\n            totalTimeSpentHours: Math.round((totalTimeSpent / 3600) * 100) / 100,\n            uniqueIssues,\n            uniqueAuthors,\n            worklogs,\n        };\n        res.json({\n            message: `Worklogs for account ${account} for ${year}-${month.toString().padStart(2, \"0\")} fetched successfully`,\n            data: JSON.stringify(summary),\n        });\n    }\n    catch (error) {\n        console.error(`Error fetching worklogs for account ${account}:`, error);\n        res.json({\n            message: `Error fetching worklogs for account ${account}: ${error.message}`,\n            data: JSON.stringify({ error: error.message }),\n        });\n    }\n}));\n// Workstream Orphan Detector API route\nmetricsRoute.get(\"/jiraReport/workstream/:workstreamKey/orphan-detector\", (req, res) => {\n    const workstreamKey = req.params.workstreamKey;\n    console.log(`Workstream Orphan Detector endpoint called for workstream: ${workstreamKey}`);\n    // Set headers for SSE\n    res.setHeader(\"Content-Type\", \"text/event-stream\");\n    res.setHeader(\"Cache-Control\", \"no-cache\");\n    res.setHeader(\"Connection\", \"keep-alive\");\n    // Send initial processing message\n    res.write(`data: ${JSON.stringify({\n        status: \"processing\",\n        step: \"initializing\",\n        message: `Starting orphan detection for workstream ${workstreamKey}...`,\n        progress: {\n            currentPhase: \"initializing\",\n            phaseProgress: 0,\n            phaseTotal: 4,\n            issuesProcessed: 0,\n            totalIssues: 0,\n            orphansFound: 0,\n            linksProcessed: 0,\n        },\n    })}\\n\\n`);\n    workstreamOrphanDetectorGraphManager\n        .detectOrphans(workstreamKey, (progress) => {\n        res.write(`data: ${JSON.stringify(progress)}\\n\\n`);\n    })\n        .then((result) => {\n        console.log(`Orphan detection completed for workstream ${workstreamKey}`);\n        // Log the structure being sent to frontend\n        console.log(`\\n=== SENDING ORPHAN DETECTOR DATA TO FRONTEND FOR ${workstreamKey} ===`);\n        console.log(`Workstream: ${result.workstream.key} - ${result.workstream.summary}`);\n        console.log(`Total issues in workstream: ${result.workstream.children.length}`);\n        console.log(`Total linked issues with parents: ${result.linkedIssuesWithParents.length}`);\n        console.log(`=== END ORPHAN DETECTOR DATA ===\\n`);\n        // Send completion message with data\n        res.write(`data: ${JSON.stringify({\n            status: \"complete\",\n            data: JSON.stringify({\n                workstream: result.workstream,\n                linkedIssuesWithParents: result.linkedIssuesWithParents,\n            }),\n            hasData: result.workstream.children.length > 0,\n        })}\\n\\n`);\n        res.end();\n    })\n        .catch((error) => {\n        console.error(`Error in orphan detection for workstream ${workstreamKey}:`, error);\n        // Send error message\n        res.write(`data: ${JSON.stringify({\n            status: \"error\",\n            message: `Error in orphan detection for workstream ${workstreamKey}: ${error.message}`,\n        })}\\n\\n`);\n        res.end();\n    });\n});\n// Orphan Detector Cache Management API routes\nmetricsRoute.get(\"/jiraReport/orphan-detector/cache/stats\", (req, res) => {\n    try {\n        const cacheStats = workstreamOrphanDetectorGraphManager.getCacheStats();\n        res.json({\n            message: \"Cache stats retrieved successfully\",\n            data: JSON.stringify(cacheStats),\n        });\n    }\n    catch (error) {\n        console.error(\"Error getting cache stats:\", error);\n        res.json({\n            message: \"Failed to get cache stats\",\n            data: JSON.stringify({ error: error.message }),\n        });\n    }\n});\nmetricsRoute.delete(\"/jiraReport/cache\", (req, res) => {\n    try {\n        jiraReportGraphManager.clearCache();\n        res.json({\n            message: \"Jira Report cache cleared successfully\",\n            data: JSON.stringify({ success: true }),\n        });\n    }\n    catch (error) {\n        console.error(\"Error clearing Jira Report cache:\", error);\n        res.json({\n            message: \"Failed to clear cache\",\n            data: JSON.stringify({ error: error.message }),\n        });\n    }\n});\nmetricsRoute.delete(\"/jiraReport/orphan-detector/cache\", (req, res) => {\n    try {\n        workstreamOrphanDetectorGraphManager.clearCache();\n        res.json({\n            message: \"Cache cleared successfully\",\n            data: JSON.stringify({ success: true }),\n        });\n    }\n    catch (error) {\n        console.error(\"Error clearing cache:\", error);\n        res.json({\n            message: \"Failed to clear cache\",\n            data: JSON.stringify({ error: error.message }),\n        });\n    }\n});\nmetricsRoute.delete(\"/jiraReport/orphan-detector/cache/:workstreamKey\", (req, res) => {\n    try {\n        const workstreamKey = req.params.workstreamKey;\n        workstreamOrphanDetectorGraphManager.invalidateCache(workstreamKey);\n        res.json({\n            message: `Cache invalidated for workstream ${workstreamKey}`,\n            data: JSON.stringify({ workstreamKey, success: true }),\n        });\n    }\n    catch (error) {\n        console.error(\"Error invalidating cache:\", error);\n        res.json({\n            message: \"Failed to invalidate cache\",\n            data: JSON.stringify({ error: error.message }),\n        });\n    }\n});\n// Bugs Analysis API route\nmetricsRoute.get(\"/bugsAnalysis\", (req, res) => {\n    const query = req.query.query;\n    console.log(`Bugs Analysis endpoint called with query: ${query}`);\n    bugsAnalysisGraphManager\n        .getBugsAnalysisData(query)\n        .then((data) => {\n        res.json({\n            message: \"Bugs Analysis data fetched successfully\",\n            data: JSON.stringify(data),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error in Bugs Analysis API:\", error);\n        res.json({\n            message: `Error fetching Bugs Analysis data: ${error.message}`,\n            data: JSON.stringify({ issues: [], quarterlyData: [] }),\n        });\n    });\n});\nmetricsRoute.get(\"/releases\", (req, res) => {\n    const projectKey = req.query.projectKey;\n    if (!projectKey) {\n        res.json({\n            message: \"projectKey is required\",\n            data: JSON.stringify([]),\n        });\n        return;\n    }\n    jiraRequester\n        .getReleasesFromProject(projectKey, 100)\n        .then((releases) => {\n        res.json({\n            message: \"Releases fetched successfully\",\n            data: JSON.stringify(releases),\n        });\n    })\n        .catch((error) => {\n        console.error(\"Error fetching releases:\", error);\n        res.json({\n            message: \"Error fetching releases\",\n            data: JSON.stringify([]),\n        });\n    });\n});\n\n\n\n//# sourceURL=webpack://operationalmetrics/./src/server/routes/metricsRoute.ts?");

/***/ }),

/***/ "dayjs":
/*!************************!*\
  !*** external "dayjs" ***!
  \************************/
/***/ ((module) => {

module.exports = require("dayjs");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("dotenv");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("express");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/server/prod-server.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;